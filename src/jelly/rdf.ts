// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: rdf.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "eu.ostrzyciel.jelly.core.proto.v1";

/**
 * Physical stream type
 * This determines how the data is encoded in the stream, not the logical
 * structure of the data. See LogicalStreamType for the latter.
 */
export enum PhysicalStreamType {
  /** PHYSICAL_STREAM_TYPE_UNSPECIFIED - Unspecified stream type – invalid */
  PHYSICAL_STREAM_TYPE_UNSPECIFIED = 0,
  /** PHYSICAL_STREAM_TYPE_TRIPLES - RDF triples */
  PHYSICAL_STREAM_TYPE_TRIPLES = 1,
  /** PHYSICAL_STREAM_TYPE_QUADS - RDF quads */
  PHYSICAL_STREAM_TYPE_QUADS = 2,
  /** PHYSICAL_STREAM_TYPE_GRAPHS - RDF triples grouped in graphs */
  PHYSICAL_STREAM_TYPE_GRAPHS = 3,
  UNRECOGNIZED = -1,
}

export function physicalStreamTypeFromJSON(object: any): PhysicalStreamType {
  switch (object) {
    case 0:
    case "PHYSICAL_STREAM_TYPE_UNSPECIFIED":
      return PhysicalStreamType.PHYSICAL_STREAM_TYPE_UNSPECIFIED;
    case 1:
    case "PHYSICAL_STREAM_TYPE_TRIPLES":
      return PhysicalStreamType.PHYSICAL_STREAM_TYPE_TRIPLES;
    case 2:
    case "PHYSICAL_STREAM_TYPE_QUADS":
      return PhysicalStreamType.PHYSICAL_STREAM_TYPE_QUADS;
    case 3:
    case "PHYSICAL_STREAM_TYPE_GRAPHS":
      return PhysicalStreamType.PHYSICAL_STREAM_TYPE_GRAPHS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhysicalStreamType.UNRECOGNIZED;
  }
}

export function physicalStreamTypeToJSON(object: PhysicalStreamType): string {
  switch (object) {
    case PhysicalStreamType.PHYSICAL_STREAM_TYPE_UNSPECIFIED:
      return "PHYSICAL_STREAM_TYPE_UNSPECIFIED";
    case PhysicalStreamType.PHYSICAL_STREAM_TYPE_TRIPLES:
      return "PHYSICAL_STREAM_TYPE_TRIPLES";
    case PhysicalStreamType.PHYSICAL_STREAM_TYPE_QUADS:
      return "PHYSICAL_STREAM_TYPE_QUADS";
    case PhysicalStreamType.PHYSICAL_STREAM_TYPE_GRAPHS:
      return "PHYSICAL_STREAM_TYPE_GRAPHS";
    case PhysicalStreamType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Logical stream type, according to the RDF Stream Taxonomy (RDF-STaX).
 * Type 0 is reserved for the unspecified stream type.
 * The rest of the type numbers follow the taxonomical structure of RDF-STaX.
 * For example: 1 is a subtype of 0, 13 and 23 are subtypes of 3,
 * 114 is a subtype of 14, etc.
 *
 * Types 1–4 correspond to the four base concrete stream types. Their
 * subtypes can be in most cases simply processed in the same way as
 * the base types.
 * Therefore, implementations can take the modulo 10 of the stream
 * type to determine the base type of the stream and use this information
 * to select the appropriate processing logic.
 *
 * RDF-STaX version: 1.1.2
 * https://w3id.org/stax/1.1.2
 *
 * ^ The above URL is used to automatically determine the version of RDF-STaX
 * in the Jelly protocol specification. Please keep it up-to-date and in the
 * same format.
 */
export enum LogicalStreamType {
  /** LOGICAL_STREAM_TYPE_UNSPECIFIED - Unspecified stream type – invalid */
  LOGICAL_STREAM_TYPE_UNSPECIFIED = 0,
  /**
   * LOGICAL_STREAM_TYPE_FLAT_TRIPLES - Flat RDF triple stream
   * https://w3id.org/stax/ontology#flatTripleStream
   */
  LOGICAL_STREAM_TYPE_FLAT_TRIPLES = 1,
  /**
   * LOGICAL_STREAM_TYPE_FLAT_QUADS - Flat RDF quad stream
   * https://w3id.org/stax/ontology#flatQuadStream
   */
  LOGICAL_STREAM_TYPE_FLAT_QUADS = 2,
  /**
   * LOGICAL_STREAM_TYPE_GRAPHS - RDF graph stream
   * https://w3id.org/stax/ontology#graphStream
   */
  LOGICAL_STREAM_TYPE_GRAPHS = 3,
  /**
   * LOGICAL_STREAM_TYPE_DATASETS - RDF dataset stream
   * https://w3id.org/stax/ontology#datasetStream
   */
  LOGICAL_STREAM_TYPE_DATASETS = 4,
  /**
   * LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS - RDF subject graph stream (subtype of RDF graph stream)
   * https://w3id.org/stax/ontology#subjectGraphStream
   */
  LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS = 13,
  /**
   * LOGICAL_STREAM_TYPE_NAMED_GRAPHS - RDF named graph stream (subtype of RDF dataset stream)
   * https://w3id.org/stax/ontology#namedGraphStream
   */
  LOGICAL_STREAM_TYPE_NAMED_GRAPHS = 14,
  /**
   * LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS - RDF timestamped named graph stream (subtype of RDF dataset stream)
   * https://w3id.org/stax/ontology#timestampedNamedGraphStream
   */
  LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS = 114,
  UNRECOGNIZED = -1,
}

export function logicalStreamTypeFromJSON(object: any): LogicalStreamType {
  switch (object) {
    case 0:
    case "LOGICAL_STREAM_TYPE_UNSPECIFIED":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_UNSPECIFIED;
    case 1:
    case "LOGICAL_STREAM_TYPE_FLAT_TRIPLES":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_FLAT_TRIPLES;
    case 2:
    case "LOGICAL_STREAM_TYPE_FLAT_QUADS":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_FLAT_QUADS;
    case 3:
    case "LOGICAL_STREAM_TYPE_GRAPHS":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_GRAPHS;
    case 4:
    case "LOGICAL_STREAM_TYPE_DATASETS":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_DATASETS;
    case 13:
    case "LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS;
    case 14:
    case "LOGICAL_STREAM_TYPE_NAMED_GRAPHS":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_NAMED_GRAPHS;
    case 114:
    case "LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS":
      return LogicalStreamType.LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogicalStreamType.UNRECOGNIZED;
  }
}

export function logicalStreamTypeToJSON(object: LogicalStreamType): string {
  switch (object) {
    case LogicalStreamType.LOGICAL_STREAM_TYPE_UNSPECIFIED:
      return "LOGICAL_STREAM_TYPE_UNSPECIFIED";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_FLAT_TRIPLES:
      return "LOGICAL_STREAM_TYPE_FLAT_TRIPLES";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_FLAT_QUADS:
      return "LOGICAL_STREAM_TYPE_FLAT_QUADS";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_GRAPHS:
      return "LOGICAL_STREAM_TYPE_GRAPHS";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_DATASETS:
      return "LOGICAL_STREAM_TYPE_DATASETS";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS:
      return "LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_NAMED_GRAPHS:
      return "LOGICAL_STREAM_TYPE_NAMED_GRAPHS";
    case LogicalStreamType.LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS:
      return "LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS";
    case LogicalStreamType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * RDF IRIs
 * The IRIs are reconstructed by the consumer using the prefix and name
 * lookup tables.
 */
export interface RdfIri {
  /**
   * 1-based, refers to an entry in the prefix lookup.
   *
   * 0 signifies "use the same prefix_id as in the previous IRI".
   * For this to work, IRIs must be processed strictly in order: firstly by
   * stream row, then by term (subject, predicate, object, graph). This also
   * applies recursively to RDF-star quoted triples.
   *
   * If 0 appears in the first IRI of the stream (and in any subsequent IRI),
   * this should be interpreted as an empty ("") prefix. This is for example
   * used when the prefix lookup table is disabled.
   */
  prefixId: number;
  /**
   * 1-based, refers to an entry in the name lookup.
   *
   * 0 signifies "use the previous name_id + 1". This requires the same order
   * guarantees as prefixes.
   *
   * If 0 appears in the first IRI of the stream, it should be interpreted as
   * name_id = 1.
   */
  nameId: number;
}

/** RDF literals */
export interface RdfLiteral {
  /** The lexical form of the literal (required). */
  lex: string;
  /** Language-tagged string. */
  langtag?:
    | string
    | undefined;
  /**
   * Typed literal. The datatype is a reference to an entry in the
   * datatype lookup. This value is 1-based and the value of 0
   * is invalid (in contrast to prefix_id and name_id in RdfIri).
   */
  datatype?: number | undefined;
}

/** Empty message indicating the default RDF graph. */
export interface RdfDefaultGraph {
}

/**
 * RDF triple
 *
 * For each term (subject, predicate, object), the fields are repeated for
 * performance reasons. This is to avoid the need for boxing each term in a
 * separate message.
 *
 * Note: this message allows for representing generalized RDF triples (for
 * example, with literals as predicates). Whether this is used in the stream
 * is determined by the stream options (see RdfStreamOptions).
 *
 * If no field in a given oneof is set, the term is interpreted as a repeated
 * term – the same as the term in the same position in the previous triple.
 * In the first triple of the stream, all terms must be set.
 * All terms must also be set in quoted triples (RDF-star).
 */
export interface RdfTriple {
  /** IRI */
  sIri?:
    | RdfIri
    | undefined;
  /** Blank node */
  sBnode?:
    | string
    | undefined;
  /**
   * Literal
   * Only valid in a generalized RDF stream.
   */
  sLiteral?:
    | RdfLiteral
    | undefined;
  /** RDF-star quoted triple */
  sTripleTerm?:
    | RdfTriple
    | undefined;
  /** IRI */
  pIri?:
    | RdfIri
    | undefined;
  /**
   * Blank node
   * Only valid in a generalized RDF stream.
   */
  pBnode?:
    | string
    | undefined;
  /**
   * Literal
   * Only valid in a generalized RDF stream.
   */
  pLiteral?:
    | RdfLiteral
    | undefined;
  /** RDF-star quoted triple */
  pTripleTerm?:
    | RdfTriple
    | undefined;
  /** IRI */
  oIri?:
    | RdfIri
    | undefined;
  /** Blank node */
  oBnode?:
    | string
    | undefined;
  /** Literal */
  oLiteral?:
    | RdfLiteral
    | undefined;
  /** RDF-star quoted triple */
  oTripleTerm?: RdfTriple | undefined;
}

/**
 * RDF quad
 *
 * Fields 1–12 are repeated from RdfTriple for performance reasons.
 *
 * Similarly to RdfTriple, this message allows for representing generalized
 * RDF quads (for example, with literals as predicates). Whether this is used
 * in the stream is determined by the stream options (see RdfStreamOptions).
 *
 * If no field in a given oneof is set, the term is interpreted as a repeated
 * term – the same as the term in the same position in the previous quad.
 * In the first quad of the stream, all terms must be set.
 */
export interface RdfQuad {
  /** IRI */
  sIri?:
    | RdfIri
    | undefined;
  /** Blank node */
  sBnode?:
    | string
    | undefined;
  /**
   * Literal
   * Only valid in a generalized RDF stream.
   */
  sLiteral?:
    | RdfLiteral
    | undefined;
  /** RDF-star quoted triple */
  sTripleTerm?:
    | RdfTriple
    | undefined;
  /** IRI */
  pIri?:
    | RdfIri
    | undefined;
  /**
   * Blank node
   * Only valid in a generalized RDF stream.
   */
  pBnode?:
    | string
    | undefined;
  /**
   * Literal
   * Only valid in a generalized RDF stream.
   */
  pLiteral?:
    | RdfLiteral
    | undefined;
  /** RDF-star quoted triple */
  pTripleTerm?:
    | RdfTriple
    | undefined;
  /** IRI */
  oIri?:
    | RdfIri
    | undefined;
  /** Blank node */
  oBnode?:
    | string
    | undefined;
  /** Literal */
  oLiteral?:
    | RdfLiteral
    | undefined;
  /** RDF-star quoted triple */
  oTripleTerm?:
    | RdfTriple
    | undefined;
  /** IRI */
  gIri?:
    | RdfIri
    | undefined;
  /** Blank node */
  gBnode?:
    | string
    | undefined;
  /** Default graph */
  gDefaultGraph?:
    | RdfDefaultGraph
    | undefined;
  /** Literal – only valid for generalized RDF streams */
  gLiteral?: RdfLiteral | undefined;
}

/**
 * Start of a graph in a GRAPHS stream
 *
 * In contrast to RdfQuad, setting the graph oneof to some value
 * is always required. No repeated terms are allowed.
 */
export interface RdfGraphStart {
  /** IRI */
  gIri?:
    | RdfIri
    | undefined;
  /** Blank node */
  gBnode?:
    | string
    | undefined;
  /** Default graph */
  gDefaultGraph?:
    | RdfDefaultGraph
    | undefined;
  /** Literal – only valid for generalized RDF streams */
  gLiteral?: RdfLiteral | undefined;
}

/** End of a graph in a GRAPHS stream */
export interface RdfGraphEnd {
}

/**
 * Explicit namespace declaration
 *
 * This does not correspond to any construct in the RDF Abstract Syntax.
 * Rather, it is a hint to the consumer that the given IRI prefix (namespace)
 * may be associated with a shorter name, like in Turtle syntax:
 * PREFIX ex: <http://example.org/>
 *
 * These short names (here "ex:") are NOT used in the RDF statement encoding.
 * This is a purely cosmetic feature useful in cases where you want to
 * preserve the namespace declarations from the original RDF document.
 * These declarations have nothing in common with the prefix lookup table.
 */
export interface RdfNamespaceDeclaration {
  /**
   * Short name of the namespace (e.g., "ex")
   * Do NOT include the colon.
   */
  name: string;
  /** IRI of the namespace (e.g., "http://example.org/") */
  value: RdfIri | undefined;
}

/** Entry in the name lookup table */
export interface RdfNameEntry {
  /**
   * 1-based identifier
   * If id=0, it should be interpreted as previous_id + 1.
   * If id=0 appears in the first RdfNameEntry of the stream, it should be
   * interpreted as 1.
   */
  id: number;
  /** Value of the name (UTF-8 encoded) */
  value: string;
}

/**
 * Entry in the prefix lookup table
 *
 * Note: the prefixes in the lookup table can be arbitrary strings, and are
 * NOT meant to be user-facing. They are only used for IRI compression.
 * To transmit user-facing namespace declarations for cosmetic purposes, use
 * RdfNamespaceDeclaration.
 */
export interface RdfPrefixEntry {
  /**
   * 1-based identifier
   * If id=0, it should be interpreted as previous_id + 1.
   * If id=0 appears in the first RdfPrefixEntry of the stream, it should be
   * interpreted as 1.
   */
  id: number;
  /** Value of the prefix (UTF-8 encoded) */
  value: string;
}

/** Entry in the datatype lookup table */
export interface RdfDatatypeEntry {
  /**
   * 1-based identifier
   * If id=0, it should be interpreted as previous_id + 1.
   * If id=0 appears in the first RdfDatatypeEntry of the stream, it should be
   * interpreted as 1.
   */
  id: number;
  /** Value of the datatype (UTF-8 encoded) */
  value: string;
}

/** RDF stream options */
export interface RdfStreamOptions {
  /**
   * Name of the stream (completely optional).
   * This may be used for, e.g., topic names in a pub/sub system.
   */
  streamName: string;
  /** Type of the stream (required) */
  physicalType: PhysicalStreamType;
  /** Whether the stream may contain generalized triples, quads, or datasets */
  generalizedStatements: boolean;
  /** Whether the stream may contain RDF-star statements */
  rdfStar: boolean;
  /**
   * Maximum size of the name lookup table
   * (required, must be >= 8)
   */
  maxNameTableSize: number;
  /**
   * Maximum size of the prefix lookup table
   * (required if the prefix lookup is used)
   */
  maxPrefixTableSize: number;
  /**
   * Maximum size of the datatype lookup table
   * (required if datatype literals are used)
   */
  maxDatatypeTableSize: number;
  /**
   * Logical (RDF-STaX-based) stream type
   * In contrast to the physical type, this field is entirely optional.
   */
  logicalType: LogicalStreamType;
  /**
   * Protocol version (required)
   * For Jelly 1.0.x value must be 1.
   * For Jelly 1.1.x value must be 2.
   * For custom extensions, the value must be 10000 or higher.
   */
  version: number;
}

/** RDF stream row */
export interface RdfStreamRow {
  /** Stream options. Must occur at the start of the stream. */
  options?:
    | RdfStreamOptions
    | undefined;
  /**
   * RDF triple statement.
   * Valid in streams of physical type TRIPLES or GRAPHS.
   */
  triple?:
    | RdfTriple
    | undefined;
  /**
   * RDF quad statement.
   * Only valid in streams of physical type QUADS.
   */
  quad?:
    | RdfQuad
    | undefined;
  /**
   * Graph boundary: ends the currently transmitted graph and starts a new one
   * Only valid in streams of physical type GRAPHS.
   */
  graphStart?:
    | RdfGraphStart
    | undefined;
  /**
   * Explicit end of a graph.
   * Signals the consumer that the transmitted graph is complete.
   * Only valid in streams of physical type GRAPHS.
   */
  graphEnd?:
    | RdfGraphEnd
    | undefined;
  /** Explicit namespace declaration. */
  namespace?:
    | RdfNamespaceDeclaration
    | undefined;
  /** Entry in the name lookup table. */
  name?:
    | RdfNameEntry
    | undefined;
  /** Entry in the prefix lookup table. */
  prefix?:
    | RdfPrefixEntry
    | undefined;
  /** Entry in the datatype lookup table. */
  datatype?: RdfDatatypeEntry | undefined;
}

/** RDF stream frame – base message for RDF streams. */
export interface RdfStreamFrame {
  /** Stream rows */
  rows: RdfStreamRow[];
  /**
   * Arbitrary metadata
   * The keys are UTF-8 encoded strings, the values are byte arrays.
   * This may be used by implementations in any way they see fit.
   * The metadata does not affect the RDF data in any way, treat it
   * as comments in a text file.
   */
  metadata: { [key: string]: Uint8Array };
}

export interface RdfStreamFrame_MetadataEntry {
  key: string;
  value: Uint8Array;
}

function createBaseRdfIri(): RdfIri {
  return { prefixId: 0, nameId: 0 };
}

export const RdfIri: MessageFns<RdfIri> = {
  encode(message: RdfIri, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefixId !== 0) {
      writer.uint32(8).uint32(message.prefixId);
    }
    if (message.nameId !== 0) {
      writer.uint32(16).uint32(message.nameId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfIri {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfIri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.prefixId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nameId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfIri {
    return {
      prefixId: isSet(object.prefixId) ? globalThis.Number(object.prefixId) : 0,
      nameId: isSet(object.nameId) ? globalThis.Number(object.nameId) : 0,
    };
  },

  toJSON(message: RdfIri): unknown {
    const obj: any = {};
    if (message.prefixId !== 0) {
      obj.prefixId = Math.round(message.prefixId);
    }
    if (message.nameId !== 0) {
      obj.nameId = Math.round(message.nameId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfIri>, I>>(base?: I): RdfIri {
    return RdfIri.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfIri>, I>>(object: I): RdfIri {
    const message = createBaseRdfIri();
    message.prefixId = object.prefixId ?? 0;
    message.nameId = object.nameId ?? 0;
    return message;
  },
};

function createBaseRdfLiteral(): RdfLiteral {
  return { lex: "", langtag: undefined, datatype: undefined };
}

export const RdfLiteral: MessageFns<RdfLiteral> = {
  encode(message: RdfLiteral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lex !== "") {
      writer.uint32(10).string(message.lex);
    }
    if (message.langtag !== undefined) {
      writer.uint32(18).string(message.langtag);
    }
    if (message.datatype !== undefined) {
      writer.uint32(24).uint32(message.datatype);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfLiteral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfLiteral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.langtag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.datatype = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfLiteral {
    return {
      lex: isSet(object.lex) ? globalThis.String(object.lex) : "",
      langtag: isSet(object.langtag) ? globalThis.String(object.langtag) : undefined,
      datatype: isSet(object.datatype) ? globalThis.Number(object.datatype) : undefined,
    };
  },

  toJSON(message: RdfLiteral): unknown {
    const obj: any = {};
    if (message.lex !== "") {
      obj.lex = message.lex;
    }
    if (message.langtag !== undefined) {
      obj.langtag = message.langtag;
    }
    if (message.datatype !== undefined) {
      obj.datatype = Math.round(message.datatype);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfLiteral>, I>>(base?: I): RdfLiteral {
    return RdfLiteral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfLiteral>, I>>(object: I): RdfLiteral {
    const message = createBaseRdfLiteral();
    message.lex = object.lex ?? "";
    message.langtag = object.langtag ?? undefined;
    message.datatype = object.datatype ?? undefined;
    return message;
  },
};

function createBaseRdfDefaultGraph(): RdfDefaultGraph {
  return {};
}

export const RdfDefaultGraph: MessageFns<RdfDefaultGraph> = {
  encode(_: RdfDefaultGraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfDefaultGraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfDefaultGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RdfDefaultGraph {
    return {};
  },

  toJSON(_: RdfDefaultGraph): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfDefaultGraph>, I>>(base?: I): RdfDefaultGraph {
    return RdfDefaultGraph.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfDefaultGraph>, I>>(_: I): RdfDefaultGraph {
    const message = createBaseRdfDefaultGraph();
    return message;
  },
};

function createBaseRdfTriple(): RdfTriple {
  return {
    sIri: undefined,
    sBnode: undefined,
    sLiteral: undefined,
    sTripleTerm: undefined,
    pIri: undefined,
    pBnode: undefined,
    pLiteral: undefined,
    pTripleTerm: undefined,
    oIri: undefined,
    oBnode: undefined,
    oLiteral: undefined,
    oTripleTerm: undefined,
  };
}

export const RdfTriple: MessageFns<RdfTriple> = {
  encode(message: RdfTriple, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sIri !== undefined) {
      RdfIri.encode(message.sIri, writer.uint32(10).fork()).join();
    }
    if (message.sBnode !== undefined) {
      writer.uint32(18).string(message.sBnode);
    }
    if (message.sLiteral !== undefined) {
      RdfLiteral.encode(message.sLiteral, writer.uint32(26).fork()).join();
    }
    if (message.sTripleTerm !== undefined) {
      RdfTriple.encode(message.sTripleTerm, writer.uint32(34).fork()).join();
    }
    if (message.pIri !== undefined) {
      RdfIri.encode(message.pIri, writer.uint32(42).fork()).join();
    }
    if (message.pBnode !== undefined) {
      writer.uint32(50).string(message.pBnode);
    }
    if (message.pLiteral !== undefined) {
      RdfLiteral.encode(message.pLiteral, writer.uint32(58).fork()).join();
    }
    if (message.pTripleTerm !== undefined) {
      RdfTriple.encode(message.pTripleTerm, writer.uint32(66).fork()).join();
    }
    if (message.oIri !== undefined) {
      RdfIri.encode(message.oIri, writer.uint32(74).fork()).join();
    }
    if (message.oBnode !== undefined) {
      writer.uint32(82).string(message.oBnode);
    }
    if (message.oLiteral !== undefined) {
      RdfLiteral.encode(message.oLiteral, writer.uint32(90).fork()).join();
    }
    if (message.oTripleTerm !== undefined) {
      RdfTriple.encode(message.oTripleTerm, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfTriple {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfTriple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sBnode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sTripleTerm = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pBnode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pTripleTerm = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.oIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.oBnode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.oLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.oTripleTerm = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfTriple {
    return {
      sIri: isSet(object.sIri) ? RdfIri.fromJSON(object.sIri) : undefined,
      sBnode: isSet(object.sBnode) ? globalThis.String(object.sBnode) : undefined,
      sLiteral: isSet(object.sLiteral) ? RdfLiteral.fromJSON(object.sLiteral) : undefined,
      sTripleTerm: isSet(object.sTripleTerm) ? RdfTriple.fromJSON(object.sTripleTerm) : undefined,
      pIri: isSet(object.pIri) ? RdfIri.fromJSON(object.pIri) : undefined,
      pBnode: isSet(object.pBnode) ? globalThis.String(object.pBnode) : undefined,
      pLiteral: isSet(object.pLiteral) ? RdfLiteral.fromJSON(object.pLiteral) : undefined,
      pTripleTerm: isSet(object.pTripleTerm) ? RdfTriple.fromJSON(object.pTripleTerm) : undefined,
      oIri: isSet(object.oIri) ? RdfIri.fromJSON(object.oIri) : undefined,
      oBnode: isSet(object.oBnode) ? globalThis.String(object.oBnode) : undefined,
      oLiteral: isSet(object.oLiteral) ? RdfLiteral.fromJSON(object.oLiteral) : undefined,
      oTripleTerm: isSet(object.oTripleTerm) ? RdfTriple.fromJSON(object.oTripleTerm) : undefined,
    };
  },

  toJSON(message: RdfTriple): unknown {
    const obj: any = {};
    if (message.sIri !== undefined) {
      obj.sIri = RdfIri.toJSON(message.sIri);
    }
    if (message.sBnode !== undefined) {
      obj.sBnode = message.sBnode;
    }
    if (message.sLiteral !== undefined) {
      obj.sLiteral = RdfLiteral.toJSON(message.sLiteral);
    }
    if (message.sTripleTerm !== undefined) {
      obj.sTripleTerm = RdfTriple.toJSON(message.sTripleTerm);
    }
    if (message.pIri !== undefined) {
      obj.pIri = RdfIri.toJSON(message.pIri);
    }
    if (message.pBnode !== undefined) {
      obj.pBnode = message.pBnode;
    }
    if (message.pLiteral !== undefined) {
      obj.pLiteral = RdfLiteral.toJSON(message.pLiteral);
    }
    if (message.pTripleTerm !== undefined) {
      obj.pTripleTerm = RdfTriple.toJSON(message.pTripleTerm);
    }
    if (message.oIri !== undefined) {
      obj.oIri = RdfIri.toJSON(message.oIri);
    }
    if (message.oBnode !== undefined) {
      obj.oBnode = message.oBnode;
    }
    if (message.oLiteral !== undefined) {
      obj.oLiteral = RdfLiteral.toJSON(message.oLiteral);
    }
    if (message.oTripleTerm !== undefined) {
      obj.oTripleTerm = RdfTriple.toJSON(message.oTripleTerm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfTriple>, I>>(base?: I): RdfTriple {
    return RdfTriple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfTriple>, I>>(object: I): RdfTriple {
    const message = createBaseRdfTriple();
    message.sIri = (object.sIri !== undefined && object.sIri !== null) ? RdfIri.fromPartial(object.sIri) : undefined;
    message.sBnode = object.sBnode ?? undefined;
    message.sLiteral = (object.sLiteral !== undefined && object.sLiteral !== null)
      ? RdfLiteral.fromPartial(object.sLiteral)
      : undefined;
    message.sTripleTerm = (object.sTripleTerm !== undefined && object.sTripleTerm !== null)
      ? RdfTriple.fromPartial(object.sTripleTerm)
      : undefined;
    message.pIri = (object.pIri !== undefined && object.pIri !== null) ? RdfIri.fromPartial(object.pIri) : undefined;
    message.pBnode = object.pBnode ?? undefined;
    message.pLiteral = (object.pLiteral !== undefined && object.pLiteral !== null)
      ? RdfLiteral.fromPartial(object.pLiteral)
      : undefined;
    message.pTripleTerm = (object.pTripleTerm !== undefined && object.pTripleTerm !== null)
      ? RdfTriple.fromPartial(object.pTripleTerm)
      : undefined;
    message.oIri = (object.oIri !== undefined && object.oIri !== null) ? RdfIri.fromPartial(object.oIri) : undefined;
    message.oBnode = object.oBnode ?? undefined;
    message.oLiteral = (object.oLiteral !== undefined && object.oLiteral !== null)
      ? RdfLiteral.fromPartial(object.oLiteral)
      : undefined;
    message.oTripleTerm = (object.oTripleTerm !== undefined && object.oTripleTerm !== null)
      ? RdfTriple.fromPartial(object.oTripleTerm)
      : undefined;
    return message;
  },
};

function createBaseRdfQuad(): RdfQuad {
  return {
    sIri: undefined,
    sBnode: undefined,
    sLiteral: undefined,
    sTripleTerm: undefined,
    pIri: undefined,
    pBnode: undefined,
    pLiteral: undefined,
    pTripleTerm: undefined,
    oIri: undefined,
    oBnode: undefined,
    oLiteral: undefined,
    oTripleTerm: undefined,
    gIri: undefined,
    gBnode: undefined,
    gDefaultGraph: undefined,
    gLiteral: undefined,
  };
}

export const RdfQuad: MessageFns<RdfQuad> = {
  encode(message: RdfQuad, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sIri !== undefined) {
      RdfIri.encode(message.sIri, writer.uint32(10).fork()).join();
    }
    if (message.sBnode !== undefined) {
      writer.uint32(18).string(message.sBnode);
    }
    if (message.sLiteral !== undefined) {
      RdfLiteral.encode(message.sLiteral, writer.uint32(26).fork()).join();
    }
    if (message.sTripleTerm !== undefined) {
      RdfTriple.encode(message.sTripleTerm, writer.uint32(34).fork()).join();
    }
    if (message.pIri !== undefined) {
      RdfIri.encode(message.pIri, writer.uint32(42).fork()).join();
    }
    if (message.pBnode !== undefined) {
      writer.uint32(50).string(message.pBnode);
    }
    if (message.pLiteral !== undefined) {
      RdfLiteral.encode(message.pLiteral, writer.uint32(58).fork()).join();
    }
    if (message.pTripleTerm !== undefined) {
      RdfTriple.encode(message.pTripleTerm, writer.uint32(66).fork()).join();
    }
    if (message.oIri !== undefined) {
      RdfIri.encode(message.oIri, writer.uint32(74).fork()).join();
    }
    if (message.oBnode !== undefined) {
      writer.uint32(82).string(message.oBnode);
    }
    if (message.oLiteral !== undefined) {
      RdfLiteral.encode(message.oLiteral, writer.uint32(90).fork()).join();
    }
    if (message.oTripleTerm !== undefined) {
      RdfTriple.encode(message.oTripleTerm, writer.uint32(98).fork()).join();
    }
    if (message.gIri !== undefined) {
      RdfIri.encode(message.gIri, writer.uint32(106).fork()).join();
    }
    if (message.gBnode !== undefined) {
      writer.uint32(114).string(message.gBnode);
    }
    if (message.gDefaultGraph !== undefined) {
      RdfDefaultGraph.encode(message.gDefaultGraph, writer.uint32(122).fork()).join();
    }
    if (message.gLiteral !== undefined) {
      RdfLiteral.encode(message.gLiteral, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfQuad {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfQuad();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sBnode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sTripleTerm = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pBnode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pTripleTerm = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.oIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.oBnode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.oLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.oTripleTerm = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.gIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gBnode = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.gDefaultGraph = RdfDefaultGraph.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.gLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfQuad {
    return {
      sIri: isSet(object.sIri) ? RdfIri.fromJSON(object.sIri) : undefined,
      sBnode: isSet(object.sBnode) ? globalThis.String(object.sBnode) : undefined,
      sLiteral: isSet(object.sLiteral) ? RdfLiteral.fromJSON(object.sLiteral) : undefined,
      sTripleTerm: isSet(object.sTripleTerm) ? RdfTriple.fromJSON(object.sTripleTerm) : undefined,
      pIri: isSet(object.pIri) ? RdfIri.fromJSON(object.pIri) : undefined,
      pBnode: isSet(object.pBnode) ? globalThis.String(object.pBnode) : undefined,
      pLiteral: isSet(object.pLiteral) ? RdfLiteral.fromJSON(object.pLiteral) : undefined,
      pTripleTerm: isSet(object.pTripleTerm) ? RdfTriple.fromJSON(object.pTripleTerm) : undefined,
      oIri: isSet(object.oIri) ? RdfIri.fromJSON(object.oIri) : undefined,
      oBnode: isSet(object.oBnode) ? globalThis.String(object.oBnode) : undefined,
      oLiteral: isSet(object.oLiteral) ? RdfLiteral.fromJSON(object.oLiteral) : undefined,
      oTripleTerm: isSet(object.oTripleTerm) ? RdfTriple.fromJSON(object.oTripleTerm) : undefined,
      gIri: isSet(object.gIri) ? RdfIri.fromJSON(object.gIri) : undefined,
      gBnode: isSet(object.gBnode) ? globalThis.String(object.gBnode) : undefined,
      gDefaultGraph: isSet(object.gDefaultGraph) ? RdfDefaultGraph.fromJSON(object.gDefaultGraph) : undefined,
      gLiteral: isSet(object.gLiteral) ? RdfLiteral.fromJSON(object.gLiteral) : undefined,
    };
  },

  toJSON(message: RdfQuad): unknown {
    const obj: any = {};
    if (message.sIri !== undefined) {
      obj.sIri = RdfIri.toJSON(message.sIri);
    }
    if (message.sBnode !== undefined) {
      obj.sBnode = message.sBnode;
    }
    if (message.sLiteral !== undefined) {
      obj.sLiteral = RdfLiteral.toJSON(message.sLiteral);
    }
    if (message.sTripleTerm !== undefined) {
      obj.sTripleTerm = RdfTriple.toJSON(message.sTripleTerm);
    }
    if (message.pIri !== undefined) {
      obj.pIri = RdfIri.toJSON(message.pIri);
    }
    if (message.pBnode !== undefined) {
      obj.pBnode = message.pBnode;
    }
    if (message.pLiteral !== undefined) {
      obj.pLiteral = RdfLiteral.toJSON(message.pLiteral);
    }
    if (message.pTripleTerm !== undefined) {
      obj.pTripleTerm = RdfTriple.toJSON(message.pTripleTerm);
    }
    if (message.oIri !== undefined) {
      obj.oIri = RdfIri.toJSON(message.oIri);
    }
    if (message.oBnode !== undefined) {
      obj.oBnode = message.oBnode;
    }
    if (message.oLiteral !== undefined) {
      obj.oLiteral = RdfLiteral.toJSON(message.oLiteral);
    }
    if (message.oTripleTerm !== undefined) {
      obj.oTripleTerm = RdfTriple.toJSON(message.oTripleTerm);
    }
    if (message.gIri !== undefined) {
      obj.gIri = RdfIri.toJSON(message.gIri);
    }
    if (message.gBnode !== undefined) {
      obj.gBnode = message.gBnode;
    }
    if (message.gDefaultGraph !== undefined) {
      obj.gDefaultGraph = RdfDefaultGraph.toJSON(message.gDefaultGraph);
    }
    if (message.gLiteral !== undefined) {
      obj.gLiteral = RdfLiteral.toJSON(message.gLiteral);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfQuad>, I>>(base?: I): RdfQuad {
    return RdfQuad.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfQuad>, I>>(object: I): RdfQuad {
    const message = createBaseRdfQuad();
    message.sIri = (object.sIri !== undefined && object.sIri !== null) ? RdfIri.fromPartial(object.sIri) : undefined;
    message.sBnode = object.sBnode ?? undefined;
    message.sLiteral = (object.sLiteral !== undefined && object.sLiteral !== null)
      ? RdfLiteral.fromPartial(object.sLiteral)
      : undefined;
    message.sTripleTerm = (object.sTripleTerm !== undefined && object.sTripleTerm !== null)
      ? RdfTriple.fromPartial(object.sTripleTerm)
      : undefined;
    message.pIri = (object.pIri !== undefined && object.pIri !== null) ? RdfIri.fromPartial(object.pIri) : undefined;
    message.pBnode = object.pBnode ?? undefined;
    message.pLiteral = (object.pLiteral !== undefined && object.pLiteral !== null)
      ? RdfLiteral.fromPartial(object.pLiteral)
      : undefined;
    message.pTripleTerm = (object.pTripleTerm !== undefined && object.pTripleTerm !== null)
      ? RdfTriple.fromPartial(object.pTripleTerm)
      : undefined;
    message.oIri = (object.oIri !== undefined && object.oIri !== null) ? RdfIri.fromPartial(object.oIri) : undefined;
    message.oBnode = object.oBnode ?? undefined;
    message.oLiteral = (object.oLiteral !== undefined && object.oLiteral !== null)
      ? RdfLiteral.fromPartial(object.oLiteral)
      : undefined;
    message.oTripleTerm = (object.oTripleTerm !== undefined && object.oTripleTerm !== null)
      ? RdfTriple.fromPartial(object.oTripleTerm)
      : undefined;
    message.gIri = (object.gIri !== undefined && object.gIri !== null) ? RdfIri.fromPartial(object.gIri) : undefined;
    message.gBnode = object.gBnode ?? undefined;
    message.gDefaultGraph = (object.gDefaultGraph !== undefined && object.gDefaultGraph !== null)
      ? RdfDefaultGraph.fromPartial(object.gDefaultGraph)
      : undefined;
    message.gLiteral = (object.gLiteral !== undefined && object.gLiteral !== null)
      ? RdfLiteral.fromPartial(object.gLiteral)
      : undefined;
    return message;
  },
};

function createBaseRdfGraphStart(): RdfGraphStart {
  return { gIri: undefined, gBnode: undefined, gDefaultGraph: undefined, gLiteral: undefined };
}

export const RdfGraphStart: MessageFns<RdfGraphStart> = {
  encode(message: RdfGraphStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gIri !== undefined) {
      RdfIri.encode(message.gIri, writer.uint32(10).fork()).join();
    }
    if (message.gBnode !== undefined) {
      writer.uint32(18).string(message.gBnode);
    }
    if (message.gDefaultGraph !== undefined) {
      RdfDefaultGraph.encode(message.gDefaultGraph, writer.uint32(26).fork()).join();
    }
    if (message.gLiteral !== undefined) {
      RdfLiteral.encode(message.gLiteral, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfGraphStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfGraphStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gIri = RdfIri.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gBnode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gDefaultGraph = RdfDefaultGraph.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gLiteral = RdfLiteral.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfGraphStart {
    return {
      gIri: isSet(object.gIri) ? RdfIri.fromJSON(object.gIri) : undefined,
      gBnode: isSet(object.gBnode) ? globalThis.String(object.gBnode) : undefined,
      gDefaultGraph: isSet(object.gDefaultGraph) ? RdfDefaultGraph.fromJSON(object.gDefaultGraph) : undefined,
      gLiteral: isSet(object.gLiteral) ? RdfLiteral.fromJSON(object.gLiteral) : undefined,
    };
  },

  toJSON(message: RdfGraphStart): unknown {
    const obj: any = {};
    if (message.gIri !== undefined) {
      obj.gIri = RdfIri.toJSON(message.gIri);
    }
    if (message.gBnode !== undefined) {
      obj.gBnode = message.gBnode;
    }
    if (message.gDefaultGraph !== undefined) {
      obj.gDefaultGraph = RdfDefaultGraph.toJSON(message.gDefaultGraph);
    }
    if (message.gLiteral !== undefined) {
      obj.gLiteral = RdfLiteral.toJSON(message.gLiteral);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfGraphStart>, I>>(base?: I): RdfGraphStart {
    return RdfGraphStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfGraphStart>, I>>(object: I): RdfGraphStart {
    const message = createBaseRdfGraphStart();
    message.gIri = (object.gIri !== undefined && object.gIri !== null) ? RdfIri.fromPartial(object.gIri) : undefined;
    message.gBnode = object.gBnode ?? undefined;
    message.gDefaultGraph = (object.gDefaultGraph !== undefined && object.gDefaultGraph !== null)
      ? RdfDefaultGraph.fromPartial(object.gDefaultGraph)
      : undefined;
    message.gLiteral = (object.gLiteral !== undefined && object.gLiteral !== null)
      ? RdfLiteral.fromPartial(object.gLiteral)
      : undefined;
    return message;
  },
};

function createBaseRdfGraphEnd(): RdfGraphEnd {
  return {};
}

export const RdfGraphEnd: MessageFns<RdfGraphEnd> = {
  encode(_: RdfGraphEnd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfGraphEnd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfGraphEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RdfGraphEnd {
    return {};
  },

  toJSON(_: RdfGraphEnd): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfGraphEnd>, I>>(base?: I): RdfGraphEnd {
    return RdfGraphEnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfGraphEnd>, I>>(_: I): RdfGraphEnd {
    const message = createBaseRdfGraphEnd();
    return message;
  },
};

function createBaseRdfNamespaceDeclaration(): RdfNamespaceDeclaration {
  return { name: "", value: undefined };
}

export const RdfNamespaceDeclaration: MessageFns<RdfNamespaceDeclaration> = {
  encode(message: RdfNamespaceDeclaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      RdfIri.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfNamespaceDeclaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfNamespaceDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RdfIri.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfNamespaceDeclaration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? RdfIri.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RdfNamespaceDeclaration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = RdfIri.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfNamespaceDeclaration>, I>>(base?: I): RdfNamespaceDeclaration {
    return RdfNamespaceDeclaration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfNamespaceDeclaration>, I>>(object: I): RdfNamespaceDeclaration {
    const message = createBaseRdfNamespaceDeclaration();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RdfIri.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRdfNameEntry(): RdfNameEntry {
  return { id: 0, value: "" };
}

export const RdfNameEntry: MessageFns<RdfNameEntry> = {
  encode(message: RdfNameEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfNameEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfNameEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfNameEntry {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RdfNameEntry): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfNameEntry>, I>>(base?: I): RdfNameEntry {
    return RdfNameEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfNameEntry>, I>>(object: I): RdfNameEntry {
    const message = createBaseRdfNameEntry();
    message.id = object.id ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRdfPrefixEntry(): RdfPrefixEntry {
  return { id: 0, value: "" };
}

export const RdfPrefixEntry: MessageFns<RdfPrefixEntry> = {
  encode(message: RdfPrefixEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfPrefixEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfPrefixEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfPrefixEntry {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RdfPrefixEntry): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfPrefixEntry>, I>>(base?: I): RdfPrefixEntry {
    return RdfPrefixEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfPrefixEntry>, I>>(object: I): RdfPrefixEntry {
    const message = createBaseRdfPrefixEntry();
    message.id = object.id ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRdfDatatypeEntry(): RdfDatatypeEntry {
  return { id: 0, value: "" };
}

export const RdfDatatypeEntry: MessageFns<RdfDatatypeEntry> = {
  encode(message: RdfDatatypeEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfDatatypeEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfDatatypeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfDatatypeEntry {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RdfDatatypeEntry): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfDatatypeEntry>, I>>(base?: I): RdfDatatypeEntry {
    return RdfDatatypeEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfDatatypeEntry>, I>>(object: I): RdfDatatypeEntry {
    const message = createBaseRdfDatatypeEntry();
    message.id = object.id ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRdfStreamOptions(): RdfStreamOptions {
  return {
    streamName: "",
    physicalType: 0,
    generalizedStatements: false,
    rdfStar: false,
    maxNameTableSize: 0,
    maxPrefixTableSize: 0,
    maxDatatypeTableSize: 0,
    logicalType: 0,
    version: 0,
  };
}

export const RdfStreamOptions: MessageFns<RdfStreamOptions> = {
  encode(message: RdfStreamOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamName !== "") {
      writer.uint32(10).string(message.streamName);
    }
    if (message.physicalType !== 0) {
      writer.uint32(16).int32(message.physicalType);
    }
    if (message.generalizedStatements !== false) {
      writer.uint32(24).bool(message.generalizedStatements);
    }
    if (message.rdfStar !== false) {
      writer.uint32(32).bool(message.rdfStar);
    }
    if (message.maxNameTableSize !== 0) {
      writer.uint32(72).uint32(message.maxNameTableSize);
    }
    if (message.maxPrefixTableSize !== 0) {
      writer.uint32(80).uint32(message.maxPrefixTableSize);
    }
    if (message.maxDatatypeTableSize !== 0) {
      writer.uint32(88).uint32(message.maxDatatypeTableSize);
    }
    if (message.logicalType !== 0) {
      writer.uint32(112).int32(message.logicalType);
    }
    if (message.version !== 0) {
      writer.uint32(120).uint32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfStreamOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfStreamOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.streamName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.physicalType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.generalizedStatements = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rdfStar = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxNameTableSize = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxPrefixTableSize = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxDatatypeTableSize = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.logicalType = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfStreamOptions {
    return {
      streamName: isSet(object.streamName) ? globalThis.String(object.streamName) : "",
      physicalType: isSet(object.physicalType) ? physicalStreamTypeFromJSON(object.physicalType) : 0,
      generalizedStatements: isSet(object.generalizedStatements)
        ? globalThis.Boolean(object.generalizedStatements)
        : false,
      rdfStar: isSet(object.rdfStar) ? globalThis.Boolean(object.rdfStar) : false,
      maxNameTableSize: isSet(object.maxNameTableSize) ? globalThis.Number(object.maxNameTableSize) : 0,
      maxPrefixTableSize: isSet(object.maxPrefixTableSize) ? globalThis.Number(object.maxPrefixTableSize) : 0,
      maxDatatypeTableSize: isSet(object.maxDatatypeTableSize) ? globalThis.Number(object.maxDatatypeTableSize) : 0,
      logicalType: isSet(object.logicalType) ? logicalStreamTypeFromJSON(object.logicalType) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: RdfStreamOptions): unknown {
    const obj: any = {};
    if (message.streamName !== "") {
      obj.streamName = message.streamName;
    }
    if (message.physicalType !== 0) {
      obj.physicalType = physicalStreamTypeToJSON(message.physicalType);
    }
    if (message.generalizedStatements !== false) {
      obj.generalizedStatements = message.generalizedStatements;
    }
    if (message.rdfStar !== false) {
      obj.rdfStar = message.rdfStar;
    }
    if (message.maxNameTableSize !== 0) {
      obj.maxNameTableSize = Math.round(message.maxNameTableSize);
    }
    if (message.maxPrefixTableSize !== 0) {
      obj.maxPrefixTableSize = Math.round(message.maxPrefixTableSize);
    }
    if (message.maxDatatypeTableSize !== 0) {
      obj.maxDatatypeTableSize = Math.round(message.maxDatatypeTableSize);
    }
    if (message.logicalType !== 0) {
      obj.logicalType = logicalStreamTypeToJSON(message.logicalType);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfStreamOptions>, I>>(base?: I): RdfStreamOptions {
    return RdfStreamOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfStreamOptions>, I>>(object: I): RdfStreamOptions {
    const message = createBaseRdfStreamOptions();
    message.streamName = object.streamName ?? "";
    message.physicalType = object.physicalType ?? 0;
    message.generalizedStatements = object.generalizedStatements ?? false;
    message.rdfStar = object.rdfStar ?? false;
    message.maxNameTableSize = object.maxNameTableSize ?? 0;
    message.maxPrefixTableSize = object.maxPrefixTableSize ?? 0;
    message.maxDatatypeTableSize = object.maxDatatypeTableSize ?? 0;
    message.logicalType = object.logicalType ?? 0;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseRdfStreamRow(): RdfStreamRow {
  return {
    options: undefined,
    triple: undefined,
    quad: undefined,
    graphStart: undefined,
    graphEnd: undefined,
    namespace: undefined,
    name: undefined,
    prefix: undefined,
    datatype: undefined,
  };
}

export const RdfStreamRow: MessageFns<RdfStreamRow> = {
  encode(message: RdfStreamRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.options !== undefined) {
      RdfStreamOptions.encode(message.options, writer.uint32(10).fork()).join();
    }
    if (message.triple !== undefined) {
      RdfTriple.encode(message.triple, writer.uint32(18).fork()).join();
    }
    if (message.quad !== undefined) {
      RdfQuad.encode(message.quad, writer.uint32(26).fork()).join();
    }
    if (message.graphStart !== undefined) {
      RdfGraphStart.encode(message.graphStart, writer.uint32(34).fork()).join();
    }
    if (message.graphEnd !== undefined) {
      RdfGraphEnd.encode(message.graphEnd, writer.uint32(42).fork()).join();
    }
    if (message.namespace !== undefined) {
      RdfNamespaceDeclaration.encode(message.namespace, writer.uint32(50).fork()).join();
    }
    if (message.name !== undefined) {
      RdfNameEntry.encode(message.name, writer.uint32(74).fork()).join();
    }
    if (message.prefix !== undefined) {
      RdfPrefixEntry.encode(message.prefix, writer.uint32(82).fork()).join();
    }
    if (message.datatype !== undefined) {
      RdfDatatypeEntry.encode(message.datatype, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfStreamRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfStreamRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.options = RdfStreamOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.triple = RdfTriple.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quad = RdfQuad.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.graphStart = RdfGraphStart.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.graphEnd = RdfGraphEnd.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.namespace = RdfNamespaceDeclaration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.name = RdfNameEntry.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.prefix = RdfPrefixEntry.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.datatype = RdfDatatypeEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfStreamRow {
    return {
      options: isSet(object.options) ? RdfStreamOptions.fromJSON(object.options) : undefined,
      triple: isSet(object.triple) ? RdfTriple.fromJSON(object.triple) : undefined,
      quad: isSet(object.quad) ? RdfQuad.fromJSON(object.quad) : undefined,
      graphStart: isSet(object.graphStart) ? RdfGraphStart.fromJSON(object.graphStart) : undefined,
      graphEnd: isSet(object.graphEnd) ? RdfGraphEnd.fromJSON(object.graphEnd) : undefined,
      namespace: isSet(object.namespace) ? RdfNamespaceDeclaration.fromJSON(object.namespace) : undefined,
      name: isSet(object.name) ? RdfNameEntry.fromJSON(object.name) : undefined,
      prefix: isSet(object.prefix) ? RdfPrefixEntry.fromJSON(object.prefix) : undefined,
      datatype: isSet(object.datatype) ? RdfDatatypeEntry.fromJSON(object.datatype) : undefined,
    };
  },

  toJSON(message: RdfStreamRow): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = RdfStreamOptions.toJSON(message.options);
    }
    if (message.triple !== undefined) {
      obj.triple = RdfTriple.toJSON(message.triple);
    }
    if (message.quad !== undefined) {
      obj.quad = RdfQuad.toJSON(message.quad);
    }
    if (message.graphStart !== undefined) {
      obj.graphStart = RdfGraphStart.toJSON(message.graphStart);
    }
    if (message.graphEnd !== undefined) {
      obj.graphEnd = RdfGraphEnd.toJSON(message.graphEnd);
    }
    if (message.namespace !== undefined) {
      obj.namespace = RdfNamespaceDeclaration.toJSON(message.namespace);
    }
    if (message.name !== undefined) {
      obj.name = RdfNameEntry.toJSON(message.name);
    }
    if (message.prefix !== undefined) {
      obj.prefix = RdfPrefixEntry.toJSON(message.prefix);
    }
    if (message.datatype !== undefined) {
      obj.datatype = RdfDatatypeEntry.toJSON(message.datatype);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfStreamRow>, I>>(base?: I): RdfStreamRow {
    return RdfStreamRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfStreamRow>, I>>(object: I): RdfStreamRow {
    const message = createBaseRdfStreamRow();
    message.options = (object.options !== undefined && object.options !== null)
      ? RdfStreamOptions.fromPartial(object.options)
      : undefined;
    message.triple = (object.triple !== undefined && object.triple !== null)
      ? RdfTriple.fromPartial(object.triple)
      : undefined;
    message.quad = (object.quad !== undefined && object.quad !== null) ? RdfQuad.fromPartial(object.quad) : undefined;
    message.graphStart = (object.graphStart !== undefined && object.graphStart !== null)
      ? RdfGraphStart.fromPartial(object.graphStart)
      : undefined;
    message.graphEnd = (object.graphEnd !== undefined && object.graphEnd !== null)
      ? RdfGraphEnd.fromPartial(object.graphEnd)
      : undefined;
    message.namespace = (object.namespace !== undefined && object.namespace !== null)
      ? RdfNamespaceDeclaration.fromPartial(object.namespace)
      : undefined;
    message.name = (object.name !== undefined && object.name !== null)
      ? RdfNameEntry.fromPartial(object.name)
      : undefined;
    message.prefix = (object.prefix !== undefined && object.prefix !== null)
      ? RdfPrefixEntry.fromPartial(object.prefix)
      : undefined;
    message.datatype = (object.datatype !== undefined && object.datatype !== null)
      ? RdfDatatypeEntry.fromPartial(object.datatype)
      : undefined;
    return message;
  },
};

function createBaseRdfStreamFrame(): RdfStreamFrame {
  return { rows: [], metadata: {} };
}

export const RdfStreamFrame: MessageFns<RdfStreamFrame> = {
  encode(message: RdfStreamFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      RdfStreamRow.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      RdfStreamFrame_MetadataEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfStreamFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfStreamFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rows.push(RdfStreamRow.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = RdfStreamFrame_MetadataEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.metadata[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfStreamFrame {
    return {
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => RdfStreamRow.fromJSON(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RdfStreamFrame): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => RdfStreamRow.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfStreamFrame>, I>>(base?: I): RdfStreamFrame {
    return RdfStreamFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfStreamFrame>, I>>(object: I): RdfStreamFrame {
    const message = createBaseRdfStreamFrame();
    message.rows = object.rows?.map((e) => RdfStreamRow.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRdfStreamFrame_MetadataEntry(): RdfStreamFrame_MetadataEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const RdfStreamFrame_MetadataEntry: MessageFns<RdfStreamFrame_MetadataEntry> = {
  encode(message: RdfStreamFrame_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RdfStreamFrame_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRdfStreamFrame_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RdfStreamFrame_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RdfStreamFrame_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RdfStreamFrame_MetadataEntry>, I>>(base?: I): RdfStreamFrame_MetadataEntry {
    return RdfStreamFrame_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RdfStreamFrame_MetadataEntry>, I>>(object: I): RdfStreamFrame_MetadataEntry {
    const message = createBaseRdfStreamFrame_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
