# N3.js Library Documentation

This document contains the annotated source code for the N3.js library, covering
the Lexer, Parser, Store, Stream implementations, and Writer.

---

## Table of Contents

1. [N3Lexer.js](https://www.google.com/search?q=%23n3lexerjs)
2. [N3Parser.js](https://www.google.com/search?q=%23n3parserjs)
3. [N3Store.js](https://www.google.com/search?q=%23n3storejs)
4. [N3StreamParser.js](https://www.google.com/search?q=%23n3streamparserjs)
5. [N3StreamWriter.js](https://www.google.com/search?q=%23n3streamwriterjs)
6. [N3Util.js](https://www.google.com/search?q=%23n3utiljs)
7. [N3Writer.js](https://www.google.com/search?q=%23n3writerjs)

---

## N3Lexer.js

**N3Lexer** tokenizes N3 documents.

```javascript
import queueMicrotask from "queue-microtask";
import namespaces from "./IRIs";

const { xsd } = namespaces;
```

Regular expression and replacement string to escape N3 strings.

```javascript
const escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;

const escapeReplacements = {
  "\\": "\\",
  "'": "'",
  '"': '"',
  "n": "\n",
  "r": "\r",
  "t": "\t",
  "f": "\f",
  "b": "\b",
  "_": "_",
  "~~": "~~",
  ".": ".",
  "-": "-",
  "!": "!",
  "$": "$",
  "&": "&",
  "(": "(",
  ")": ")",
  "_": "_",
  "+": "+",
  ",": ",",
  ";": ";",
  "=": "=",
  "/": "/",
  "?": "?",
  "#": "#",
  "@": "@",
  "%": "%",
};

const illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;

const lineModeRegExps = {
  _iri: true,
  _unescapedIri: true,
  _simpleQuotedString: true,
  _langcode: true,
  _blank: true,
  _newline: true,
  _comment: true,
  _whitespace: true,
  _endOfFile: true,
};

const invalidRegExp = /$0^/;
```

### Constructor

```javascript
export default class N3Lexer {
  constructor(options) {
```

### Regular expressions

It’s slightly faster to have these as properties than as in-scope variables.

```javascript
this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/; // IRI with escape sequences; needs sanity check after unescaping
this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/; // IRI without escape sequences; no unescaping
this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/; // string without escape sequences
this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
this._prefix =
  /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
this._prefixed =
  /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
this._variable =
  /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
this._blank =
  /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
this._number =
  /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
this._keyword = /^@[a-z]+(?=[\s#<:])/i;
this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/;
this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
this._comment = /#([^\n\r]*)/;
this._whitespace = /^[ \t]+/;
this._endOfFile = /^(?:#[^\n\r]*)?$/;
options = options || {};
```

In line mode (N-Triples or N-Quads), only simple features may be parsed.

```javascript
if (this._lineMode = !!options.lineMode) {
  this._n3Mode = false;
```

Don’t tokenize special literals.

```javascript
  for (const key in this) {
    if (!(key in lineModeRegExps) && this[key] instanceof RegExp)
      this[key] = invalidRegExp;
  }
}
```

When not in line mode, enable N3 functionality by default.

```javascript
else {
  this._n3Mode = options.n3 !== false;
}
```

Don’t output comment tokens by default.

```javascript
this._comments = !!options.comments;
```

Cache the last tested closing position of long literals.

```javascript
  this._literalClosingPos = 0;
}
```

### Private methods

`_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the
callback.

```javascript
_tokenizeToEnd(callback, inputFinished) {
```

Continue parsing as far as possible; the loop will return eventually.

```javascript
let input = this._input;
let currentLineLength = input.length;
while (true) {
```

Count and skip whitespace lines.

```javascript
let whiteSpaceMatch, comment;
while (whiteSpaceMatch = this._newline.exec(input)) {
```

Try to find a comment.

```javascript
if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0]))) {
  emitToken("comment", comment[1], "", this._line, whiteSpaceMatch[0].length);
}
```

Advance the input.

```javascript
  input = input.substr(whiteSpaceMatch[0].length, input.length);
  currentLineLength = input.length;
  this._line++;
}
```

Skip whitespace on current line.

```javascript
if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) {
  input = input.substr(whiteSpaceMatch[0].length, input.length);
}
```

Stop for now if we’re at the end.

```javascript
if (this._endOfFile.test(input)) {
```

If the input is finished, emit EOF.

```javascript
if (inputFinished) {
```

Try to find a final comment.

```javascript
    if (this._comments && (comment = this._comment.exec(input)))
      emitToken('comment', comment[1], '', this._line, input.length);
    input = null;
    emitToken('eof', '', '', this._line, 0);
  }
  return this._input = input;
}
```

Look for specific token types based on the first character.

```javascript
const line = this._line, firstChar = input[0];
let type = '', value = '', prefix = '',
    match = null, matchLength = 0, inconclusive = false;
switch (firstChar) {
case '^':
```

We need at least 3 tokens lookahead to distinguish `^^<iri>` and `^^pre:fixed`.

```javascript
if (input.length < 3) {
  break;
}
```

Try to match a type.

```javascript
else if (input[1] === '^') {
  this._previousMarker = '^^';
```

Move to type IRI or prefixed name.

```javascript
  input = input.substr(2);
  if (input[0] !== '<') {
    inconclusive = true;
    break;
  }
}
```

If no type, it must be a path expression.

```javascript
else {
  if (this._n3Mode) {
    matchLength = 1;
    type = '^';
  }
  break;
}
```

Fall through in case the type is an IRI.

```javascript
case '<':
```

Try to find a full IRI without escape sequences.

```javascript
if (match = this._unescapedIri.exec(input)) {
  type = "IRI", value = match[1];
}
```

Try to find a full IRI with escape sequences.

```javascript
else if (match = this._iri.exec(input)) {
  value = this._unescape(match[1]);
  if (value === null || illegalIriChars.test(value))
    return reportSyntaxError(this);
  type = 'IRI';
}
```

Try to find a nested triple.

```javascript
else if (input.length > 1 && input[1] === '<')
  type = '<<', matchLength = 2;
```

Try to find a backwards implication arrow.

```javascript
        else if (this._n3Mode && input.length > 1 && input[1] === '=')
          type = 'inverse', matchLength = 2, value = '>';
        break;

      case '>':
        if (input.length > 1 && input[1] === '>')
          type = '>>', matchLength = 2;
        break;

      case '_':
```

Try to find a blank node. Since it can contain (but not end with) a dot, we
always need a non-dot character before deciding it is a blank node. Therefore,
try inserting a space if we’re at the end of the input.

```javascript
        if ((match = this._blank.exec(input)) ||
            inputFinished && (match = this._blank.exec(`${input} `)))
          type = 'blank', prefix = '_', value = match[1];
        break;

      case '"':
```

Try to find a literal without escape sequences.

```javascript
if (match = this._simpleQuotedString.exec(input)) {
  value = match[1];
}
```

Try to find a literal wrapped in three pairs of quotes.

```javascript
        else {
          ({ value, matchLength } = this._parseLiteral(input));
          if (value === null)
            return reportSyntaxError(this);
        }
        if (match !== null || matchLength !== 0) {
          type = 'literal';
          this._literalClosingPos = 0;
        }
        break;

      case "'":
        if (!this._lineMode) {
```

Try to find a literal without escape sequences.

```javascript
if (match = this._simpleApostropheString.exec(input)) {
  value = match[1];
}
```

Try to find a literal wrapped in three pairs of quotes.

```javascript
          else {
            ({ value, matchLength } = this._parseLiteral(input));
            if (value === null)
              return reportSyntaxError(this);
          }
          if (match !== null || matchLength !== 0) {
            type = 'literal';
            this._literalClosingPos = 0;
          }
        }
        break;

      case '?':
```

Try to find a variable.

```javascript
        if (this._n3Mode && (match = this._variable.exec(input)))
          type = 'var', value = match[0];
        break;

      case '@':
```

Try to find a language code.

```javascript
if (
  this._previousMarker === "literal" && (match = this._langcode.exec(input))
) {
  type = "langcode", value = match[1];
}
```

Try to find a keyword.

```javascript
        else if (match = this._keyword.exec(input))
          type = match[0];
        break;

      case '.':
```

Try to find a dot as punctuation.

```javascript
if (input.length === 1 ? inputFinished : (input[1] < "0" || input[1] > "9")) {
  type = ".";
  matchLength = 1;
  break;
}
```

Fall through to numerical case (could be a decimal dot).

```javascript
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
case '+':
case '-':
```

Try to find a number. Since it can contain (but not end with) a dot, we always
need a non-dot character before deciding it is a number. Therefore, try
inserting a space if we’re at the end of the input.

```javascript
        if (match = this._number.exec(input) ||
            inputFinished && (match = this._number.exec(`${input} `))) {
          type = 'literal', value = match[0];
          prefix = (typeof match[1] === 'string' ? xsd.double :
                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));
        }
        break;

      case 'B':
      case 'b':
      case 'p':
      case 'P':
      case 'G':
      case 'g':
```

Try to find a SPARQL-style keyword.

```javascript
        if (match = this._sparqlKeyword.exec(input))
          type = match[0].toUpperCase();
        else
          inconclusive = true;
        break;

      case 'f':
      case 't':
```

Try to match a boolean.

```javascript
        if (match = this._boolean.exec(input))
          type = 'literal', value = match[0], prefix = xsd.boolean;
        else
          inconclusive = true;
        break;

      case 'a':
```

Try to find an abbreviated predicate.

```javascript
        if (match = this._shortPredicates.exec(input))
          type = 'abbreviation', value = 'a';
        else
          inconclusive = true;
        break;

      case '=':
```

Try to find an implication arrow or equals sign.

```javascript
        if (this._n3Mode && input.length > 1) {
          type = 'abbreviation';
          if (input[1] !== '>')
            matchLength = 1, value = '=';
          else
            matchLength = 2, value = '>';
        }
        break;

      case '!':
        if (!this._n3Mode)
          break;
      case ',':
      case ';':
      case '[':
      case ']':
      case '(':
      case ')':
      case '}':
        if (!this._lineMode) {
          matchLength = 1;
          type = firstChar;
        }
        break;
      case '{':
```

We need at least 2 tokens lookahead to distinguish `{|` and `{`.

```javascript
if (!this._lineMode && input.length >= 2) {
```

Try to find a quoted triple annotation start.

```javascript
    if (input[1] === '|')
      type = '{|', matchLength = 2;
    else
      type = firstChar, matchLength = 1;
  }
  break;
case '|':
```

We need 2 tokens lookahead to parse `|}`. Try to find a quoted triple annotation
end.

```javascript
        if (input.length >= 2 && input[1] === '}')
          type = '|}', matchLength = 2;
        break;

      default:
        inconclusive = true;
      }
```

Some first characters do not allow an immediate decision, so inspect more.

```javascript
if (inconclusive) {
```

Try to find a prefix.

```javascript
if (
  (this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") &&
  (match = this._prefix.exec(input))
) {
  type = "prefix", value = match[1] || "";
}
```

Try to find a prefixed name. Since it can contain (but not end with) a dot, we
always need a non-dot character before deciding it is a prefixed name.
Therefore, try inserting a space if we’re at the end of the input.

```javascript
  else if ((match = this._prefixed.exec(input)) ||
           inputFinished && (match = this._prefixed.exec(`${input} `)))
    type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);
}
```

A type token is special: it can only be emitted after an IRI or prefixed name is
read.

```javascript
if (this._previousMarker === "^^") {
  switch (type) {
    case "prefixed":
      type = "type";
      break;
    case "IRI":
      type = "typeIRI";
      break;
    default:
      type = "";
  }
}
```

What if nothing of the above was found?

```javascript
if (!type) {
```

We could be in streaming mode, and then we just wait for more input to arrive.
Otherwise, a syntax error has occurred in the input. One exception: error on an
unaccounted linebreak (= not inside a triple-quoted literal).

```javascript
  if (inputFinished || (!/^'''|^"""/.test(input) && /\n|\r/.test(input)))
    return reportSyntaxError(this);
  else
    return this._input = input;
}
```

Emit the parsed token.

```javascript
const length = matchLength || match[0].length;
const token = emitToken(type, value, prefix, line, length);
this.previousToken = token;
this._previousMarker = type;
```

Advance to next part to tokenize.

```javascript
  input = input.substr(length, input.length);
}
```

Emits the token through the callback.

```javascript
function emitToken(type, value, prefix, line, length) {
  const start = input ? currentLineLength - input.length : currentLineLength;
  const end = start + length;
  const token = { type, value, prefix, line, start, end };
  callback(null, token);
  return token;
}
```

Signals the syntax error through the callback.

```javascript
  function reportSyntaxError(self) { callback(self._syntaxError(/^\S*/.exec(input)[0])); }
}
```

`_unescape` replaces N3 escape codes by their corresponding characters.

```javascript
_unescape(item) {
  let invalid = false;
  const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {
```

4-digit unicode character.

```javascript
if (typeof unicode4 === "string") {
  return String.fromCharCode(Number.parseInt(unicode4, 16));
}
```

8-digit unicode character.

```javascript
if (typeof unicode8 === "string") {
  let charCode = Number.parseInt(unicode8, 16);
  return charCode <= 0xFFFF
    ? String.fromCharCode(Number.parseInt(unicode8, 16))
    : String.fromCharCode(
      0xD800 + ((charCode -= 0x10000) >> 10),
      0xDC00 + (charCode & 0x3FF),
    );
}
```

Fixed escape sequence.

```javascript
if (escapedChar in escapeReplacements) {
  return escapeReplacements[escapedChar];
}
```

Invalid escape sequence.

```javascript
    invalid = true;
    return '';
  });
  return invalid ? null : replaced;
}
```

`_parseLiteral` parses a literal into an unescaped value.

```javascript
_parseLiteral(input) {
```

Ensure we have enough lookahead to identify triple-quoted strings.

```javascript
if (input.length >= 3) {
```

Identify the opening quote(s).

```javascript
const opening = input.match(/^(?:"""|"|'''|'|)/)[0];
const openingLength = opening.length;
```

Find the next candidate closing quotes.

```javascript
let closingPos = Math.max(this._literalClosingPos, openingLength);
while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
```

Count backslashes right before the closing quotes.

```javascript
let backslashCount = 0;
while (input[closingPos - backslashCount - 1] === "\\") {
  backslashCount++;
}
```

An even number of backslashes (in particular 0) means these are actual,
non-escaped closing quotes.

```javascript
if (backslashCount % 2 === 0) {
```

Extract and unescape the value.

```javascript
const raw = input.substring(openingLength, closingPos);
const lines = raw.split(/\r\n|\r|\n/).length - 1;
const matchLength = closingPos + openingLength;
```

Only triple-quoted strings can be multi-line.

```javascript
        if (openingLength === 1 && lines !== 0 ||
            openingLength === 3 && this._lineMode)
          break;
        this._line += lines;
        return { value: this._unescape(raw), matchLength };
      }
      closingPos++;
    }
    this._literalClosingPos = input.length - openingLength + 1;
  }
  return { value: '', matchLength: 0 };
}
```

`_syntaxError` creates a syntax error for the given issue.

```javascript
_syntaxError(issue) {
  this._input = null;
  const err = new Error(`Unexpected "${issue}" on line ${this._line}.`);
  err.context = {
    token: undefined,
    line: this._line,
    previousToken: this.previousToken,
  };
  return err;
}
```

Strips off any starting UTF BOM mark.

```javascript
_readStartingBom(input) {
  return input.startsWith('\ufeff') ? input.substr(1) : input;
}
```

### Public methods

`tokenize` starts the transformation of an N3 document into an array of tokens.
The input can be a string or a stream.

```javascript
tokenize(input, callback) {
  this._line = 1;
```

If the input is a string, continuously emit tokens through the callback until
the end.

```javascript
if (typeof input === 'string') {
  this._input = this._readStartingBom(input);
```

If a callback was passed, asynchronously call it.

```javascript
if (typeof callback === "function") {
  queueMicrotask(() => this._tokenizeToEnd(callback, true));
}
```

If no callback was passed, tokenize synchronously and return.

```javascript
  else {
    const tokens = [];
    let error;
    this._tokenizeToEnd((e, t) => e ? (error = e) : tokens.push(t), true);
    if (error) throw error;
    return tokens;
  }
}
```

Otherwise, the input must be a stream.

```javascript
else {
  this._pendingBuffer = null;
  if (typeof input.setEncoding === 'function')
    input.setEncoding('utf8');
```

Adds the data chunk to the buffer and parses as far as possible.

```javascript
input.on('data', data => {
  if (this._input !== null && data.length !== 0) {
```

Prepend any previous pending writes.

```javascript
if (this._pendingBuffer) {
  data = Buffer.concat([this._pendingBuffer, data]);
  this._pendingBuffer = null;
}
```

Hold if the buffer ends in an incomplete unicode sequence.

```javascript
if (data[data.length - 1] & 0x80) {
  this._pendingBuffer = data;
}
```

Otherwise, tokenize as far as possible.

```javascript
else {
```

Only read a BOM at the start.

```javascript
      if (typeof this._input === 'undefined')
        this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());
      else
        this._input += data;
      this._tokenizeToEnd(callback, false);
    }
  }
});
```

Parses until the end.

```javascript
      input.on('end', () => {
        if (typeof this._input === 'string')
          this._tokenizeToEnd(callback, true);
      });
      input.on('error', callback);
    }
  } 
}
```

---

## N3Parser.js

**N3Parser** parses N3 documents.

```javascript
import N3Lexer from "./N3Lexer";
import N3DataFactory from "./N3DataFactory";
import namespaces from "./IRIs";

let blankNodePrefix = 0;
```

### Constructor

```javascript
export default class N3Parser {
  constructor(options) {
    this._contextStack = [];
    this._graph = null;
```

Set the document IRI.

```javascript
options = options || {};
this._setBase(options.baseIRI);
options.factory && initDataFactory(this, options.factory);
```

Set supported features depending on the format.

```javascript
const format = (typeof options.format === "string")
    ? options.format.match(/\w*$/)[0].toLowerCase()
    : "",
  isTurtle = /turtle/.test(format),
  isTriG = /trig/.test(format),
  isNTriples = /triple/.test(format),
  isNQuads = /quad/.test(format),
  isN3 = this._n3Mode = /n3/.test(format),
  isLineMode = isNTriples || isNQuads;
if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) {
  this._readPredicateOrNamedGraph = this._readPredicate;
}
```

Support triples in other graphs.

```javascript
this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);
```

Support nesting of triples.

```javascript
this._supportsRDFStar = format === "" || /star|\*$/.test(format);
```

Disable relative IRIs in N-Triples or N-Quads mode.

```javascript
if (isLineMode) {
  this._resolveRelativeIRI = (iri) => {
    return null;
  };
}
this._blankNodePrefix = typeof options.blankNodePrefix !== "string"
  ? ""
  : options.blankNodePrefix.replace(/^(?!_:)/, "_:");
this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });
```

Disable explicit quantifiers by default.

```javascript
  this._explicitQuantifiers = !!options.explicitQuantifiers;
}
```

### Static class methods

`_resetBlankNodePrefix` restarts blank node prefix identification.

```javascript
static _resetBlankNodePrefix() {
  blankNodePrefix = 0;
}
```

### Private methods

`_setBase` sets the base IRI to resolve relative IRIs.

```javascript
_setBase(baseIRI) {
  if (!baseIRI) {
    this._base = '';
    this._basePath = '';
  }
  else {
```

Remove fragment if present.

```javascript
const fragmentPos = baseIRI.indexOf("#");
if (fragmentPos >= 0) {
  baseIRI = baseIRI.substr(0, fragmentPos);
}
```

Set base IRI and its components.

```javascript
    this._base = baseIRI;
    this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :
                       baseIRI.replace(/[^\/?]*(?:\?.*)?$/, '');
    baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
    this._baseRoot   = baseIRI[0];
    this._baseScheme = baseIRI[1];
  }
}
```

`_saveContext` stores the current parsing context when entering a new scope
(list, blank node, formula).

```javascript
_saveContext(type, graph, subject, predicate, object) {
  const n3Mode = this._n3Mode;
  this._contextStack.push({
    type,
    subject, predicate, object, graph,
    inverse: n3Mode ? this._inversePredicate : false,
    blankPrefix: n3Mode ? this._prefixes._ : '',
    quantified: n3Mode ? this._quantified : null,
  });
```

The settings below only apply to N3 streams.

```javascript
if (n3Mode) {
```

Every new scope resets the predicate direction.

```javascript
this._inversePredicate = false;
```

In N3, blank nodes are scoped to a formula (using a dot as separator, as a blank
node label cannot start with it).

```javascript
this._prefixes._ = this._graph ? `${this._graph.value}.` : ".";
```

Quantifiers are scoped to a formula.

```javascript
    this._quantified = Object.create(this._quantified);
  }
}
```

`_restoreContext` restores the parent context when leaving a scope (list, blank
node, formula).

```javascript
_restoreContext(type, token) {
```

Obtain the previous context.

```javascript
const context = this._contextStack.pop();
if (!context || context.type !== type) {
  return this._error(`Unexpected ${token.type}`, token);
}
```

Restore the quad of the previous context.

```javascript
this._subject = context.subject;
this._predicate = context.predicate;
this._object = context.object;
this._graph = context.graph;
```

Restore N3 context settings.

```javascript
  if (this._n3Mode) {
    this._inversePredicate = context.inverse;
    this._prefixes._ = context.blankPrefix;
    this._quantified = context.quantified;
  }
}
```

`_readInTopContext` reads a token when in the top context.

```javascript
_readInTopContext(token) {
  switch (token.type) {
```

If an EOF token arrives in the top context, signal that we’re done.

```javascript
case 'eof':
  if (this._graph !== null)
    return this._error('Unclosed graph', token);
  delete this._prefixes._;
  return this._callback(null, null, this._prefixes);
```

It could be a prefix declaration.

```javascript
case 'PREFIX':
  this._sparqlStyle = true;
case '@prefix':
  return this._readPrefix;
```

It could be a base declaration.

```javascript
case 'BASE':
  this._sparqlStyle = true;
case '@base':
  return this._readBaseIRI;
```

It could be a graph.

```javascript
case '{':
  if (this._supportsNamedGraphs) {
    this._graph = '';
    this._subject = null;
    return this._readSubject;
  }
case 'GRAPH':
  if (this._supportsNamedGraphs)
    return this._readNamedGraphLabel;
```

Otherwise, the next token must be a subject.

```javascript
  default:
    return this._readSubject(token);
  }
}
```

`_readEntity` reads an IRI, prefixed name, blank node, or variable.

```javascript
_readEntity(token, quantifier) {
  let value;
  switch (token.type) {
```

Read a relative or absolute IRI.

```javascript
case 'IRI':
case 'typeIRI':
  const iri = this._resolveIRI(token.value);
  if (iri === null)
    return this._error('Invalid IRI', token);
  value = this._namedNode(iri);
  break;
```

Read a prefixed name.

```javascript
case 'type':
case 'prefixed':
  const prefix = this._prefixes[token.prefix];
  if (prefix === undefined)
    return this._error(`Undefined prefix "${token.prefix}:"`, token);
  value = this._namedNode(prefix + token.value);
  break;
```

Read a blank node.

```javascript
case 'blank':
  value = this._blankNode(this._prefixes[token.prefix] + token.value);
  break;
```

Read a variable.

```javascript
case 'var':
  value = this._variable(token.value.substr(1));
  break;
```

Everything else is not an entity.

```javascript
default:
  return this._error(`Expected entity but got ${token.type}`, token);
}
```

In N3 mode, replace the entity if it is quantified.

```javascript
  if (!quantifier && this._n3Mode && (value.id in this._quantified))
    value = this._quantified[value.id];
  return value;
}
```

`_readSubject` reads a quad’s subject.

```javascript
_readSubject(token) {
  this._predicate = null;
  switch (token.type) {
  case '[':
```

Start a new quad with a new blank node as subject.

```javascript
  this._saveContext('blank', this._graph,
                    this._subject = this._blankNode(), null, null);
  return this._readBlankNodeHead;
case '(':
```

Start a new list.

```javascript
  this._saveContext('list', this._graph, this.RDF_NIL, null, null);
  this._subject = null;
  return this._readListItem;
case '{':
```

Start a new formula.

```javascript
  if (!this._n3Mode)
    return this._error('Unexpected graph', token);
  this._saveContext('formula', this._graph,
                    this._graph = this._blankNode(), null, null);
  return this._readSubject;
case '}':
```

No subject; the graph in which we are reading is closed instead.

```javascript
      return this._readPunctuation(token);
    case '@forSome':
      if (!this._n3Mode)
        return this._error('Unexpected "@forSome"', token);
      this._subject = null;
      this._predicate = this.N3_FORSOME;
      this._quantifier = this._blankNode;
      return this._readQuantifierList;
    case '@forAll':
      if (!this._n3Mode)
        return this._error('Unexpected "@forAll"', token);
      this._subject = null;
      this._predicate = this.N3_FORALL;
      this._quantifier = this._variable;
      return this._readQuantifierList;
    case 'literal':
      if (!this._n3Mode)
        return this._error('Unexpected literal', token);

      if (token.prefix.length === 0) {
        this._literalValue = token.value;
        return this._completeSubjectLiteral;
      }
      else
        this._subject = this._literal(token.value, this._namedNode(token.prefix));

      break;
    case '<<':
      if (!this._supportsRDFStar)
        return this._error('Unexpected RDF* syntax', token);
      this._saveContext('<<', this._graph, null, null, null);
      this._graph = null;
      return this._readSubject;
    default:
```

Read the subject entity.

```javascript
if ((this._subject = this._readEntity(token)) === undefined) {
  return;
}
```

In N3 mode, the subject might be a path.

```javascript
  if (this._n3Mode)
    return this._getPathReader(this._readPredicateOrNamedGraph);
}
```

The next token must be a predicate, or, if the subject was actually a graph IRI,
a named graph.

```javascript
  return this._readPredicateOrNamedGraph;
}
```

`_readPredicate` reads a quad’s predicate.

```javascript
_readPredicate(token) {
  const type = token.type;
  switch (type) {
  case 'inverse':
    this._inversePredicate = true;
  case 'abbreviation':
    this._predicate = this.ABBREVIATIONS[token.value];
    break;
  case '.':
  case ']':
  case '}':
```

Expected predicate didn’t come, must have been trailing semicolon.

```javascript
  if (this._predicate === null)
    return this._error(`Unexpected ${type}`, token);
  this._subject = null;
  return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);
case ';':
```

Additional semicolons can be safely ignored.

```javascript
  return this._predicate !== null ? this._readPredicate :
         this._error('Expected predicate but got ;', token);
case '[':
  if (this._n3Mode) {
```

Start a new quad with a new blank node as subject.

```javascript
    this._saveContext('blank', this._graph, this._subject,
                      this._subject = this._blankNode(), null);
    return this._readBlankNodeHead;
  }
case 'blank':
  if (!this._n3Mode)
    return this._error('Disallowed blank node as predicate', token);
default:
  if ((this._predicate = this._readEntity(token)) === undefined)
    return;
}
```

The next token must be an object.

```javascript
  return this._readObject;
}
```

`_readObject` reads a quad’s object.

```javascript
_readObject(token) {
  switch (token.type) {
  case 'literal':
```

Regular literal, can still get a datatype or language.

```javascript
if (token.prefix.length === 0) {
  this._literalValue = token.value;
  return this._readDataTypeOrLang;
}
```

Pre-datatyped string literal (prefix stores the datatype).

```javascript
  else
    this._object = this._literal(token.value, this._namedNode(token.prefix));
  break;
case '[':
```

Start a new quad with a new blank node as subject.

```javascript
  this._saveContext('blank', this._graph, this._subject, this._predicate,
                    this._subject = this._blankNode());
  return this._readBlankNodeHead;
case '(':
```

Start a new list.

```javascript
  this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);
  this._subject = null;
  return this._readListItem;
case '{':
```

Start a new formula.

```javascript
  if (!this._n3Mode)
    return this._error('Unexpected graph', token);
  this._saveContext('formula', this._graph, this._subject, this._predicate,
                    this._graph = this._blankNode());
  return this._readSubject;
case '<<':
  if (!this._supportsRDFStar)
    return this._error('Unexpected RDF* syntax', token);
  this._saveContext('<<', this._graph, this._subject, this._predicate, null);
  this._graph = null;
  return this._readSubject;
default:
```

Read the object entity.

```javascript
if ((this._object = this._readEntity(token)) === undefined) {
  return;
}
```

In N3 mode, the object might be a path.

```javascript
    if (this._n3Mode)
      return this._getPathReader(this._getContextEndReader());
  }
  return this._getContextEndReader();
}
```

`_readPredicateOrNamedGraph` reads a quad’s predicate, or a named graph.

```javascript
_readPredicateOrNamedGraph(token) {
  return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);
}
```

`_readGraph` reads a graph.

```javascript
_readGraph(token) {
  if (token.type !== '{')
    return this._error(`Expected graph but got ${token.type}`, token);
```

The “subject” we read is actually the GRAPH’s label.

```javascript
  this._graph = this._subject, this._subject = null;
  return this._readSubject;
}
```

`_readBlankNodeHead` reads the head of a blank node.

```javascript
_readBlankNodeHead(token) {
  if (token.type === ']') {
    this._subject = null;
    return this._readBlankNodeTail(token);
  }
  else {
    this._predicate = null;
    return this._readPredicate(token);
  }
}
```

`_readBlankNodeTail` reads the end of a blank node.

```javascript
_readBlankNodeTail(token) {
  if (token.type !== ']')
    return this._readBlankNodePunctuation(token);
```

Store blank node quad.

```javascript
if (this._subject !== null) {
  this._emit(this._subject, this._predicate, this._object, this._graph);
}
```

Restore the parent context containing this blank node.

```javascript
const empty = this._predicate === null;
this._restoreContext("blank", token);
```

If the blank node was the object, restore previous context and read punctuation.

```javascript
if (this._object !== null) {
  return this._getContextEndReader();
}
```

If the blank node was the predicate, continue reading the object.

```javascript
else if (this._predicate !== null)
  return this._readObject;
```

If the blank node was the subject, continue reading the predicate.

```javascript
else
```

If the blank node was empty, it could be a named graph label.

```javascript
    return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
}
```

`_readPredicateAfterBlank` reads a predicate after an anonymous blank node.

```javascript
_readPredicateAfterBlank(token) {
  switch (token.type) {
  case '.':
  case '}':
```

No predicate is coming if the triple is terminated here.

```javascript
    this._subject = null;
    return this._readPunctuation(token);
  default:
    return this._readPredicate(token);
  }
}
```

`_readListItem` reads items from a list.

```javascript
  _readListItem(token) {
    let item = null,                      // The item of the list
        list = null,                      // The list itself
        next = this._readListItem;        // The next function to execute
    const previousList = this._subject,   // The previous list that contains this list
        stack = this._contextStack,       // The stack of parent contexts
        parent = stack[stack.length - 1]; // The parent containing the current list

    switch (token.type) {
    case '[':
```

Stack the current list quad and start a new quad with a blank node as subject.

```javascript
  this._saveContext('blank', this._graph,
                    list = this._blankNode(), this.RDF_FIRST,
                    this._subject = item = this._blankNode());
  next = this._readBlankNodeHead;
  break;
case '(':
```

Stack the current list quad and start a new list.

```javascript
  this._saveContext('list', this._graph,
                    list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);
  this._subject = null;
  break;
case ')':
```

Closing the list; restore the parent context.

```javascript
this._restoreContext("list", token);
```

If this list is contained within a parent list, return the membership quad here.
This will be `<parent list element> rdf:first <this list>.`.

```javascript
if (stack.length !== 0 && stack[stack.length - 1].type === "list") {
  this._emit(this._subject, this._predicate, this._object, this._graph);
}
```

Was this list the parent’s subject?

```javascript
if (this._predicate === null) {
```

The next token is the predicate.

```javascript
next = this._readPredicate;
```

No list tail if this was an empty list.

```javascript
  if (this._subject === this.RDF_NIL)
    return next;
}
```

The list was in the parent context’s object.

```javascript
else {
  next = this._getContextEndReader();
```

No list tail if this was an empty list.

```javascript
  if (this._object === this.RDF_NIL)
    return next;
}
```

Close the list by making the head nil.

```javascript
  list = this.RDF_NIL;
  break;
case 'literal':
```

Regular literal, can still get a datatype or language.

```javascript
if (token.prefix.length === 0) {
  this._literalValue = token.value;
  next = this._readListItemDataTypeOrLang;
}
```

Pre-datatyped string literal (prefix stores the datatype).

```javascript
  else {
    item = this._literal(token.value, this._namedNode(token.prefix));
    next = this._getContextEndReader();
  }
  break;
case '{':
```

Start a new formula.

```javascript
  if (!this._n3Mode)
    return this._error('Unexpected graph', token);
  this._saveContext('formula', this._graph, this._subject, this._predicate,
                    this._graph = this._blankNode());
  return this._readSubject;
default:
  if ((item = this._readEntity(token)) === undefined)
    return;
}
```

Create a new blank node if no item head was assigned yet.

```javascript
if (list === null) {
  this._subject = list = this._blankNode();
}
```

Is this the first element of the list?

```javascript
if (previousList === null) {
```

This list is either the subject or the object of its parent.

```javascript
  if (parent.predicate === null)
    parent.subject = list;
  else
    parent.object = list;
}
else {
```

Continue the previous list with the current list.

```javascript
  this._emit(previousList, this.RDF_REST, list, this._graph);
}
```

If an item was read, add it to the list.

```javascript
if (item !== null) {
```

In N3 mode, the item might be a path.

```javascript
if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {
```

Create a new context to add the item’s path.

```javascript
this._saveContext("item", this._graph, list, this.RDF_FIRST, item);
this._subject = item, this._predicate = null;
```

`_readPath` will restore the context and output the item.

```javascript
  return this._getPathReader(this._readListItem);
}
```

Output the item.

```javascript
    this._emit(list, this.RDF_FIRST, item, this._graph);
  }
  return next;
}
```

`_readDataTypeOrLang` reads an _optional_ datatype or language.

```javascript
_readDataTypeOrLang(token) {
  return this._completeObjectLiteral(token, false);
}
```

`_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a
list.

```javascript
_readListItemDataTypeOrLang(token) {
  return this._completeObjectLiteral(token, true);
}
```

`_completeLiteral` completes a literal with an optional datatype or language.

```javascript
_completeLiteral(token) {
```

Create a simple string literal by default.

```javascript
    let literal = this._literal(this._literalValue);

    switch (token.type) {
```

Create a datatyped literal.

```javascript
case 'type':
case 'typeIRI':
  const datatype = this._readEntity(token);
  if (datatype === undefined) return; // No datatype means an error occurred
  literal = this._literal(this._literalValue, datatype);
  token = null;
  break;
```

Create a language-tagged string.

```javascript
    case 'langcode':
      literal = this._literal(this._literalValue, token.value);
      token = null;
      break;
    }

    return { token, literal };
  }
```

Completes a literal in subject position.

```javascript
_completeSubjectLiteral(token) {
  this._subject = this._completeLiteral(token).literal;
  return this._readPredicateOrNamedGraph;
}
```

Completes a literal in object position.

```javascript
_completeObjectLiteral(token, listItem) {
  const completed = this._completeLiteral(token);
  if (!completed)
    return;
  this._object = completed.literal;
```

If this literal was part of a list, write the item (we could also check the
context stack, but passing in a flag is faster).

```javascript
if (listItem) {
  this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);
}
```

If the token was consumed, continue with the rest of the input.

```javascript
if (completed.token === null) {
  return this._getContextEndReader();
}
```

Otherwise, consume the token now.

```javascript
  else {
    this._readCallback = this._getContextEndReader();
    return this._readCallback(completed.token);
  }
}
```

`_readFormulaTail` reads the end of a formula.

```javascript
_readFormulaTail(token) {
  if (token.type !== '}')
    return this._readPunctuation(token);
```

Store the last quad of the formula.

```javascript
if (this._subject !== null) {
  this._emit(this._subject, this._predicate, this._object, this._graph);
}
```

Restore the parent context containing this formula.

```javascript
this._restoreContext("formula", token);
```

If the formula was the subject, continue reading the predicate. If the formula
was the object, read punctuation.

```javascript
  return this._object === null ? this._readPredicate : this._getContextEndReader();
}
```

`_readPunctuation` reads punctuation between quads or quad parts.

```javascript
_readPunctuation(token) {
  let next, graph = this._graph;
  const subject = this._subject, inversePredicate = this._inversePredicate;
  switch (token.type) {
```

A closing brace ends a graph.

```javascript
case '}':
  if (this._graph === null)
    return this._error('Unexpected graph closing', token);
  if (this._n3Mode)
    return this._readFormulaTail(token);
  this._graph = null;
```

A dot just ends the statement, without sharing anything with the next.

```javascript
case '.':
  this._subject = null;
  next = this._contextStack.length ? this._readSubject : this._readInTopContext;
  if (inversePredicate) this._inversePredicate = false;
  break;
```

Semicolon means the subject is shared; predicate and object are different.

```javascript
case ';':
  next = this._readPredicate;
  break;
```

Comma means both the subject and predicate are shared; the object is different.

```javascript
case ',':
  next = this._readObject;
  break;
```

`{|` means that the current triple is annotated with predicate-object pairs.

```javascript
case '{|':
  if (!this._supportsRDFStar)
    return this._error('Unexpected RDF* syntax', token);
```

Continue using the last triple as quoted triple subject for the predicate-object
pairs.

```javascript
const predicate = this._predicate, object = this._object;
this._subject = this._quad(subject, predicate, object, this.DEFAULTGRAPH);
next = this._readPredicate;
break;
```

`|}` means that the current quoted triple in annotation syntax is finalized.

```javascript
case '|}':
  if (this._subject.termType !== 'Quad')
    return this._error('Unexpected asserted triple closing', token);
  this._subject = null;
  next = this._readPunctuation;
  break;
default:
```

An entity means this is a quad (only allowed if not already inside a graph).

```javascript
  if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {
    next = this._readQuadPunctuation;
    break;
  }
  return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
}
```

A quad has been completed now, so return it.

```javascript
  if (subject !== null) {
    const predicate = this._predicate, object = this._object;
    if (!inversePredicate)
      this._emit(subject, predicate, object,  graph);
    else
      this._emit(object,  predicate, subject, graph);
  }
  return next;
}
```

`_readBlankNodePunctuation` reads punctuation in a blank node.

```javascript
_readBlankNodePunctuation(token) {
  let next;
  switch (token.type) {
```

Semicolon means the subject is shared; predicate and object are different.

```javascript
case ';':
  next = this._readPredicate;
  break;
```

Comma means both the subject and predicate are shared; the object is different.

```javascript
case ',':
  next = this._readObject;
  break;
default:
  return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
}
```

A quad has been completed now, so return it.

```javascript
  this._emit(this._subject, this._predicate, this._object, this._graph);
  return next;
}
```

`_readQuadPunctuation` reads punctuation after a quad.

```javascript
_readQuadPunctuation(token) {
  if (token.type !== '.')
    return this._error('Expected dot to follow quad', token);
  return this._readInTopContext;
}
```

`_readPrefix` reads the prefix of a prefix declaration.

```javascript
_readPrefix(token) {
  if (token.type !== 'prefix')
    return this._error('Expected prefix to follow @prefix', token);
  this._prefix = token.value;
  return this._readPrefixIRI;
}
```

`_readPrefixIRI` reads the IRI of a prefix declaration.

```javascript
_readPrefixIRI(token) {
  if (token.type !== 'IRI')
    return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, token);
  const prefixNode = this._readEntity(token);
  this._prefixes[this._prefix] = prefixNode.value;
  this._prefixCallback(this._prefix, prefixNode);
  return this._readDeclarationPunctuation;
}
```

`_readBaseIRI` reads the IRI of a base declaration.

```javascript
_readBaseIRI(token) {
  const iri = token.type === 'IRI' && this._resolveIRI(token.value);
  if (!iri)
    return this._error('Expected valid IRI to follow base declaration', token);
  this._setBase(iri);
  return this._readDeclarationPunctuation;
}
```

`_readNamedGraphLabel` reads the label of a named graph.

```javascript
_readNamedGraphLabel(token) {
  switch (token.type) {
  case 'IRI':
  case 'blank':
  case 'prefixed':
    return this._readSubject(token), this._readGraph;
  case '[':
    return this._readNamedGraphBlankLabel;
  default:
    return this._error('Invalid graph label', token);
  }
}
```

`_readNamedGraphBlankLabel` reads a blank node label of a named graph.

```javascript
_readNamedGraphBlankLabel(token) {
  if (token.type !== ']')
    return this._error('Invalid graph label', token);
  this._subject = this._blankNode();
  return this._readGraph;
}
```

`_readDeclarationPunctuation` reads the punctuation of a declaration.

```javascript
_readDeclarationPunctuation(token) {
```

SPARQL-style declarations don’t have punctuation.

```javascript
    if (this._sparqlStyle) {
      this._sparqlStyle = false;
      return this._readInTopContext(token);
    }

    if (token.type !== '.')
      return this._error('Expected declaration to end with a dot', token);
    return this._readInTopContext;
  }
```

Reads a list of quantified symbols from a `@forSome` or `@forAll` statement.

```javascript
_readQuantifierList(token) {
  let entity;
  switch (token.type) {
  case 'IRI':
  case 'prefixed':
    if ((entity = this._readEntity(token, true)) !== undefined)
      break;
  default:
    return this._error(`Unexpected ${token.type}`, token);
  }
```

Without explicit quantifiers, map entities to a quantified entity.

```javascript
if (!this._explicitQuantifiers) {
  this._quantified[entity.id] = this._quantifier(this._blankNode().value);
}
```

With explicit quantifiers, output the reified quantifier.

```javascript
else {
```

If this is the first item, start a new quantifier list.

```javascript
if (this._subject === null) {
  this._emit(
    this._graph || this.DEFAULTGRAPH,
    this._predicate,
    this._subject = this._blankNode(),
    this.QUANTIFIERS_GRAPH,
  );
}
```

Otherwise, continue the previous list.

```javascript
else
  this._emit(this._subject, this.RDF_REST,
             this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);
```

Output the list item.

```javascript
    this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
  }
  return this._readQuantifierPunctuation;
}
```

Reads punctuation from a `@forSome` or `@forAll` statement.

```javascript
_readQuantifierPunctuation(token) {
```

Read more quantifiers.

```javascript
if (token.type === ",") {
  return this._readQuantifierList;
}
```

End of the quantifier list.

```javascript
else {
```

With explicit quantifiers, close the quantifier list.

```javascript
if (this._explicitQuantifiers) {
  this._emit(
    this._subject,
    this.RDF_REST,
    this.RDF_NIL,
    this.QUANTIFIERS_GRAPH,
  );
  this._subject = null;
}
```

Read a dot.

```javascript
    this._readCallback = this._getContextEndReader();
    return this._readCallback(token);
  }
}
```

`_getPathReader` reads a potential path and then resumes with the given
function.

```javascript
_getPathReader(afterPath) {
  this._afterPath = afterPath;
  return this._readPath;
}
```

`_readPath` reads a potential path.

```javascript
_readPath(token) {
  switch (token.type) {
```

Forward path.

```javascript
case '!': return this._readForwardPath;
```

Backward path.

```javascript
case '^': return this._readBackwardPath;
```

Not a path; resume reading where we left off.

```javascript
default:
  const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];
```

If we were reading a list item, we still need to output it.

```javascript
if (parent && parent.type === 'item') {
```

The list item is the remaining subejct after reading the path.

```javascript
const item = this._subject;
```

Switch back to the context of the list.

```javascript
this._restoreContext("item", token);
```

Output the list item.

```javascript
      this._emit(this._subject, this.RDF_FIRST, item, this._graph);
    }
    return this._afterPath(token);
  }
}
```

`_readForwardPath` reads a ‘\!’ path.

```javascript
_readForwardPath(token) {
  let subject, predicate;
  const object = this._blankNode();
```

The next token is the predicate.

```javascript
if ((predicate = this._readEntity(token)) === undefined) {
  return;
}
```

If we were reading a subject, replace the subject by the path’s object.

```javascript
if (this._predicate === null) {
  subject = this._subject, this._subject = object;
}
```

If we were reading an object, replace the subject by the path’s object.

```javascript
else
  subject = this._object,  this._object  = object;
```

Emit the path’s current quad and read its next section.

```javascript
  this._emit(subject, predicate, object, this._graph);
  return this._readPath;
}
```

`_readBackwardPath` reads a ‘^’ path.

```javascript
_readBackwardPath(token) {
  const subject = this._blankNode();
  let predicate, object;
```

The next token is the predicate.

```javascript
if ((predicate = this._readEntity(token)) === undefined) {
  return;
}
```

If we were reading a subject, replace the subject by the path’s subject.

```javascript
if (this._predicate === null) {
  object = this._subject, this._subject = subject;
}
```

If we were reading an object, replace the subject by the path’s subject.

```javascript
else
  object = this._object,  this._object  = subject;
```

Emit the path’s current quad and read its next section.

```javascript
  this._emit(subject, predicate, object, this._graph);
  return this._readPath;
}
```

`_readRDFStarTailOrGraph` reads the graph of a nested RDF\* quad or the end of a
nested RDF\* triple.

```javascript
_readRDFStarTailOrGraph(token) {
  if (token.type !== '>>') {
```

An entity means this is a quad (only allowed if not already inside a graph).

```javascript
    if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)
      return this._readRDFStarTail;
    return this._error(`Expected >> to follow "${this._object.id}"`, token);
  }
  return this._readRDFStarTail(token);
}
```

`_readRDFStarTail` reads the end of a nested RDF\* triple.

```javascript
_readRDFStarTail(token) {
  if (token.type !== '>>')
    return this._error(`Expected >> but got ${token.type}`, token);
```

Read the quad and restore the previous context.

```javascript
const quad = this._quad(
  this._subject,
  this._predicate,
  this._object,
  this._graph || this.DEFAULTGRAPH,
);
this._restoreContext("<<", token);
```

If the triple was the subject, continue by reading the predicate.

```javascript
if (this._subject === null) {
  this._subject = quad;
  return this._readPredicate;
}
```

If the triple was the object, read context end.

```javascript
  else {
    this._object = quad;
    return this._getContextEndReader();
  }
}
```

`_getContextEndReader` gets the next reader function at the end of a context.

```javascript
  _getContextEndReader() {
    const contextStack = this._contextStack;
    if (!contextStack.length)
      return this._readPunctuation;

    switch (contextStack[contextStack.length - 1].type) {
    case 'blank':
      return this._readBlankNodeTail;
    case 'list':
      return this._readListItem;
    case 'formula':
      return this._readFormulaTail;
    case '<<':
      return this._readRDFStarTailOrGraph;
    }
  }
```

`_emit` sends a quad through the callback.

```javascript
_emit(subject, predicate, object, graph) {
  this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));
}
```

`_error` emits an error message through the callback.

```javascript
_error(message, token) {
  const err = new Error(`${message} on line ${token.line}.`);
  err.context = {
    token: token,
    line: token.line,
    previousToken: this._lexer.previousToken,
  };
  this._callback(err);
  this._callback = noop;
}
```

`_resolveIRI` resolves an IRI against the base path.

```javascript
_resolveIRI(iri) {
  return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
}
```

`_resolveRelativeIRI` resolves an IRI against the base path, assuming that a
base path has been set and that the IRI is indeed relative.

```javascript
_resolveRelativeIRI(iri) {
```

An empty relative IRI indicates the base IRI.

```javascript
if (!iri.length) {
  return this._base;
}
```

Decide resolving strategy based in the first character.

```javascript
switch (iri[0]) {
```

Resolve relative fragment IRIs against the base IRI.

```javascript
case '#': return this._base + iri;
```

Resolve relative query string IRIs by replacing the query string.

```javascript
case '?': return this._base.replace(/(?:\?.*)?$/, iri);
```

Resolve root-relative IRIs at the root of the base IRI.

```javascript
case '/':
```

Resolve scheme-relative IRIs to the scheme.

```javascript
return (iri[1] === "/" ? this._baseScheme : this._baseRoot) +
  this._removeDotSegments(iri);
```

Resolve all other IRIs at the base IRI’s path.

```javascript
default:
```

Relative IRIs cannot contain a colon in the first path segment.

```javascript
    return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);
  }
}
```

`_removeDotSegments` resolves `./` and `../` path segments in an IRI as per
RFC3986.

```javascript
_removeDotSegments(iri) {
```

Don’t modify the IRI if it does not contain any dot segments.

```javascript
if (!/(^|\/)\.\.?($|[/#?])/.test(iri)) {
  return iri;
}
```

Start with an imaginary slash before the IRI in order to resolve trailing `./`
and `../`.

```javascript
    const length = iri.length;
    let result = '', i = -1, pathStart = -1, segmentStart = 0, next = '/';

    while (i < length) {
      switch (next) {
```

The path starts with the first slash after the authority.

```javascript
case ':':
  if (pathStart < 0) {
```

Skip two slashes before the authority.

```javascript
if (iri[++i] === '/' && iri[++i] === '/')
```

Skip to slash after the authority.

```javascript
    while ((pathStart = i + 1) < length && iri[pathStart] !== '/')
      i = pathStart;
}
break;
```

Don’t modify a query string or fragment.

```javascript
case '?':
case '#':
  i = length;
  break;
```

Handle `/.` or `/..` path segments.

```javascript
case '/':
  if (iri[i + 1] === '.') {
    next = iri[++i + 1];
    switch (next) {
```

Remove a `/.` segment.

```javascript
case '/':
  result += iri.substring(segmentStart, i - 1);
  segmentStart = i + 1;
  break;
```

Remove a trailing `/.` segment.

```javascript
case undefined:
case '?':
case '#':
  return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
```

Remove a `/..` segment.

```javascript
case '.':
  next = iri[++i + 1];
  if (next === undefined || next === '/' || next === '?' || next ===='#') {
    result += iri.substring(segmentStart, i - 2);
```

Try to remove the parent path from result.

```javascript
if ((segmentStart = result.lastIndexOf("/")) >= pathStart) {
  result = result.substr(0, segmentStart);
}
```

Remove a trailing `/..` segment.

```javascript
            if (next !== '/')
              return `${result}/${iri.substr(i + 1)}`;
            segmentStart = i + 1;
          }
        }
      }
    }
    next = iri[++i];
  }
  return result + iri.substring(segmentStart);
}
```

### Public methods

`parse` parses the N3 input and emits each parsed quad through the callback.

```javascript
parse(input, quadCallback, prefixCallback) {
```

The read callback is the next function to be executed when a token arrives. We
start reading in the top context.

```javascript
this._readCallback = this._readInTopContext;
this._sparqlStyle = false;
this._prefixes = Object.create(null);
this._prefixes._ = this._blankNodePrefix
  ? this._blankNodePrefix.substr(2)
  : `b${blankNodePrefix++}_`;
this._prefixCallback = prefixCallback || noop;
this._inversePredicate = false;
this._quantified = Object.create(null);
```

Parse synchronously if no quad callback is given.

```javascript
if (!quadCallback) {
  const quads = [];
  let error;
  this._callback = (e, t) => {
    e ? (error = e) : t && quads.push(t);
  };
  this._lexer.tokenize(input).every((token) => {
    return this._readCallback = this._readCallback(token);
  });
  if (error) throw error;
  return quads;
}
```

Parse asynchronously otherwise, executing the read callback when a token
arrives.

```javascript
    this._callback = quadCallback;
    this._lexer.tokenize(input, (error, token) => {
      if (error !== null)
        this._callback(error), this._callback = noop;
      else if (this._readCallback)
        this._readCallback = this._readCallback(token);
    });
  } 
}
```

The empty function.

```javascript
function noop() {}
```

Initializes the parser with the given data factory.

```javascript
function initDataFactory(parser, factory) {
```

Set factory methods.

```javascript
const namedNode = factory.namedNode;

parser._namedNode = namedNode;
parser._blankNode = factory.blankNode;
parser._literal = factory.literal;
parser._variable = factory.variable;
parser._quad = factory.quad;
parser.DEFAULTGRAPH = factory.defaultGraph();
```

Set common named nodes.

```javascript
  parser.RDF_FIRST  = namedNode(namespaces.rdf.first);
  parser.RDF_REST = namedNode(namespaces.rdf.rest);
  parser.RDF_NIL = namedNode(namespaces.rdf.nil);
  parser.N3_FORALL = namedNode(namespaces.r.forAll);
  parser.N3_FORSOME = namedNode(namespaces.r.forSome);
  parser.ABBREVIATIONS = {
    'a': namedNode(namespaces.rdf.type),
    '=': namedNode(namespaces.owl.sameAs),
    '>': namedNode(namespaces.log.implies),
  };
  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');
}

initDataFactory(N3Parser.prototype, N3DataFactory);
```

---

## N3Store.js

**N3Store** objects store N3 quads by graph in memory.

```javascript
import { Readable } from "readable-stream";
import {
  default as N3DataFactory,
  termFromId,
  termToId,
} from "./N3DataFactory";
import namespaces from "./IRIs";
import { isDefaultGraph } from "./N3Util";
```

### Constructor

```javascript
export default class N3Store {
  constructor(quads, options) {
```

The number of quads is initially zero.

```javascript
this._size = 0;
```

`_graphs` contains subject, predicate, and object indexes per graph.

```javascript
this._graphs = Object.create(null);
```

`_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers, saving
memory by using only numbers as keys in `_graphs`.

```javascript
this._id = 0;
this._ids = Object.create(null);
this._entities = Object.create(null); // inverse of `_ids`
```

`_blankNodeIndex` is the index of the last automatically named blank node.

```javascript
this._blankNodeIndex = 0;
```

Shift parameters if `quads` is not given.

```javascript
if (!options && quads && !quads[0]) {
  options = quads, quads = null;
}
options = options || {};
this._factory = options.factory || N3DataFactory;
```

Add quads if passed.

```javascript
    if (quads)
      this.addQuads(quads);
  }

  _termFromId(id, factory) {
    if (id[0] === '.') {
      const entities = this._entities;
      const terms = id.split('.');
      const q = this._factory.quad(
        this._termFromId(entities[terms[1]]),
        this._termFromId(entities[terms[2]]),
        this._termFromId(entities[terms[3]]),
        terms[4] && this._termFromId(entities[terms[4]])
      );
      return q;
    }
    return termFromId(id, factory);
  }

  _termToNumericId(term) {
    if (term.termType === 'Quad') {
      const s = this._termToNumericId(term.subject),
            p = this._termToNumericId(term.predicate),
            o = this._termToNumericId(term.object);
      let g;

      return s && p && o && (isDefaultGraph(term.graph) || (g = this._termToNumericId(term.graph))) &&
        this._ids[g ? `.${s}.${p}.${o}.${g}` : `.${s}.${p}.${o}`];
    }
    return this._ids[termToId(term)];
  }

  _termToNewNumericId(term) {
```

This assumes that no graph term is present - we may wish to error if there is
one.

```javascript
    const str = term && term.termType === 'Quad' ?
      `.${this._termToNewNumericId(term.subject)}.${this._termToNewNumericId(term.predicate)}.${this._termToNewNumericId(term.object)}${
        isDefaultGraph(term.graph) ? '' : `.${this._termToNewNumericId(term.graph)}`
      }`
      : termToId(term);

    return this._ids[str] || (this._ids[this._entities[++this._id] = str] = this._id);
  }
```

### Public properties

`size` returns the number of quads in the store.

```javascript
get size() {
```

Return the quad count if if was cached.

```javascript
let size = this._size;
if (size !== null) {
  return size;
}
```

Calculate the number of quads by counting to the deepest level.

```javascript
  size = 0;
  const graphs = this._graphs;
  let subjects, subject;
  for (const graphKey in graphs)
    for (const subjectKey in (subjects = graphs[graphKey].subjects))
      for (const predicateKey in (subject = subjects[subjectKey]))
        size += Object.keys(subject[predicateKey]).length;
  return this._size = size;
}
```

### Private methods

`_addToIndex` adds a quad to a three-layered index. Returns if the index has
changed, if the entry did not already exist.

```javascript
_addToIndex(index0, key0, key1, key2) {
```

Create layers as necessary.

```javascript
const index1 = index0[key0] || (index0[key0] = {});
const index2 = index1[key1] || (index1[key1] = {});
```

Setting the key to _any_ value signals the presence of the quad.

```javascript
  const existed = key2 in index2;
  if (!existed)
    index2[key2] = null;
  return !existed;
}
```

`_removeFromIndex` removes a quad from a three-layered index.

```javascript
_removeFromIndex(index0, key0, key1, key2) {
```

Remove the quad from the index.

```javascript
const index1 = index0[key0], index2 = index1[key1];
delete index2[key2];
```

Remove intermediary index layers if they are empty.

```javascript
  for (const key in index2) return;
  delete index1[key1];
  for (const key in index1) return;
  delete index0[key0];
}
```

`_findInIndex` finds a set of quads in a three-layered index. The index base is
`index0` and the keys at each level are `key0`, `key1`, and `key2`. Any of these
keys can be undefined, which is interpreted as a wildcard. `name0`, `name1`, and
`name2` are the names of the keys at each level, used when reconstructing the
resulting quad (for instance: _subject_, _predicate_, and _object_). Finally,
`graphId` will be the graph of the created quads.

```javascript
*_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {
  let tmp, index1, index2;
  const entityKeys = this._entities;
  const graph = this._termFromId(graphId, this._factory);
  const parts = { subject: null, predicate: null, object: null };
```

If a key is specified, use only that part of index 0.

```javascript
if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];
for (const value0 in index0) {
  if (index1 = index0[value0]) {
    parts[name0] = this._termFromId(entityKeys[value0], this._factory);
```

If a key is specified, use only that part of index 1.

```javascript
if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];
for (const value1 in index1) {
  if (index2 = index1[value1]) {
    parts[name1] = this._termFromId(entityKeys[value1], this._factory);
```

If a key is specified, use only that part of index 2, if it exists.

```javascript
const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);
```

Create quads for all items found in index 2.

```javascript
          for (let l = 0; l < values.length; l++) {
            parts[name2] = this._termFromId(entityKeys[values[l]], this._factory);
            yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);
          }
        }
      }
    }
  }
}
```

`_loop` executes the callback on all keys of index 0.

```javascript
_loop(index0, callback) {
  for (const key0 in index0)
    callback(key0);
}
```

`_loopByKey0` executes the callback on all keys of a certain entry in index 0.

```javascript
_loopByKey0(index0, key0, callback) {
  let index1, key1;
  if (index1 = index0[key0]) {
    for (key1 in index1)
      callback(key1);
  }
}
```

`_loopByKey1` executes the callback on given keys of all entries in index 0.

```javascript
_loopByKey1(index0, key1, callback) {
  let key0, index1;
  for (key0 in index0) {
    index1 = index0[key0];
    if (index1[key1])
      callback(key0);
  }
}
```

`_loopBy2Keys` executes the callback on given keys of certain entries in
index 2.

```javascript
_loopBy2Keys(index0, key0, key1, callback) {
  let index1, index2, key2;
  if ((index1 = index0[key0]) && (index2 = index1[key1])) {
    for (key2 in index2)
      callback(key2);
  }
}
```

`_countInIndex` counts matching quads in a three-layered index. The index base
is `index0` and the keys at each level are `key0`, `key1`, and `key2`. Any of
these keys can be undefined, which is interpreted as a wildcard.

```javascript
_countInIndex(index0, key0, key1, key2) {
  let count = 0, tmp, index1, index2;
```

If a key is specified, count only that part of index 0.

```javascript
if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];
for (const value0 in index0) {
  if (index1 = index0[value0]) {
```

If a key is specified, count only that part of index 1.

```javascript
if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];
for (const value1 in index1) {
  if (index2 = index1[value1]) {
```

If a key is specified, count the quad if it exists.

```javascript
if (key2) (key2 in index2) && count++;
```

Otherwise, count all quads.

```javascript
          else count += Object.keys(index2).length;
        }
      }
    }
  }
  return count;
}
```

`_getGraphs` returns an array with the given graph, or all graphs if the
argument is null or undefined.

```javascript
_getGraphs(graph) {
  if (!isString(graph))
    return this._graphs;
  const graphs = {};
  graphs[graph] = this._graphs[graph];
  return graphs;
}
```

`_uniqueEntities` returns a function that accepts an entity ID and passes the
corresponding entity to callback if it hasn’t occurred before.

```javascript
_uniqueEntities(callback) {
  const uniqueIds = Object.create(null);
  return id => {
    if (!(id in uniqueIds)) {
      uniqueIds[id] = true;
      callback(this._termFromId(this._entities[id], this._factory));
    }
  };
}
```

### Public methods

`add` adds the specified quad to the dataset. Returns the dataset instance it
was called on. Existing quads, as defined in Quad.equals, will be ignored.

```javascript
add(quad) {
  this.addQuad(quad);
  return this;
}
```

`addQuad` adds a new quad to the store. Returns if the quad index has changed,
if the quad did not already exist.

```javascript
addQuad(subject, predicate, object, graph) {
```

Shift arguments if a quad object is given instead of components.

```javascript
if (!predicate) {
  graph = subject.graph,
    object = subject.object,
    predicate = subject.predicate,
    subject = subject.subject;
}
```

Convert terms to internal string representation.

```javascript
graph = termToId(graph);
```

Find the graph that will contain the triple.

```javascript
let graphItem = this._graphs[graph];
```

Create the graph if it doesn’t exist yet.

```javascript
if (!graphItem) {
  graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };
```

Freezing a graph helps subsequent `add` performance, and properties will never
be modified anyway.

```javascript
  Object.freeze(graphItem);
}
```

Since entities can often be long IRIs, we avoid storing them in every index.
Instead, we have a separate index that maps entities to numbers, which are then
used as keys in the other indexes.

```javascript
subject = this._termToNewNumericId(subject);
predicate = this._termToNewNumericId(predicate);
object = this._termToNewNumericId(object);

const changed = this._addToIndex(
  graphItem.subjects,
  subject,
  predicate,
  object,
);
this._addToIndex(graphItem.predicates, predicate, object, subject);
this._addToIndex(graphItem.objects, object, subject, predicate);
```

The cached quad count is now invalid.

```javascript
  this._size = null;
  return changed;
}
```

`addQuads` adds multiple quads to the store.

```javascript
addQuads(quads) {
  for (let i = 0; i < quads.length; i++)
    this.addQuad(quads[i]);
}
```

`delete` removes the specified quad from the dataset. Returns the dataset
instance it was called on.

```javascript
delete(quad) {
  this.removeQuad(quad);
  return this;
}
```

`has` determines whether a dataset includes a certain quad or quad pattern.

```javascript
has(subjectOrQuad, predicate, object, graph) {
  if (subjectOrQuad && subjectOrQuad.subject)
    ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);
  return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;
}
```

`import` adds a stream of quads to the store.

```javascript
import(stream);
{
  stream.on("data", (quad) => {
    this.addQuad(quad);
  });
  return stream;
}
```

`removeQuad` removes a quad from the store if it exists.

```javascript
removeQuad(subject, predicate, object, graph) {
```

Shift arguments if a quad object is given instead of components.

```javascript
if (!predicate) {
  graph = subject.graph,
    object = subject.object,
    predicate = subject.predicate,
    subject = subject.subject;
}
```

Convert terms to internal string representation.

```javascript
graph = termToId(graph);
```

Find internal identifiers for all components and verify the quad exists.

```javascript
const graphs = this._graphs;
let graphItem, subjects, predicates;
if (
  !(subject = subject && this._termToNumericId(subject)) ||
  !(predicate = predicate && this._termToNumericId(predicate)) ||
  !(object = object && this._termToNumericId(object)) ||
  !(graphItem = graphs[graph]) ||
  !(subjects = graphItem.subjects[subject]) ||
  !(predicates = subjects[predicate]) ||
  !(object in predicates)
) {
  return false;
}
```

Remove it from all indexes.

```javascript
this._removeFromIndex(graphItem.subjects, subject, predicate, object);
this._removeFromIndex(graphItem.predicates, predicate, object, subject);
this._removeFromIndex(graphItem.objects, object, subject, predicate);
if (this._size !== null) this._size--;
```

Remove the graph if it is empty.

```javascript
  for (subject in graphItem.subjects) return true;
  delete graphs[graph];
  return true;
}
```

`removeQuads` removes multiple quads from the store.

```javascript
removeQuads(quads) {
  for (let i = 0; i < quads.length; i++)
    this.removeQuad(quads[i]);
}
```

`remove` removes a stream of quads from the store.

```javascript
remove(stream) {
  stream.on('data', quad => { this.removeQuad(quad); });
  return stream;
}
```

`removeMatches` removes all matching quads from the store. Setting any field to
`undefined` or `null` indicates a wildcard.

```javascript
  removeMatches(subject, predicate, object, graph) {
    const stream = new Readable({ objectMode: true });

    stream._read = () => {
      for (const quad of this.readQuads(subject, predicate, object, graph))
        stream.push(quad);
      stream.push(null);
    };

    return this.remove(stream);
  }
```

`deleteGraph` removes all triples with the given graph from the store.

```javascript
deleteGraph(graph) {
  return this.removeMatches(null, null, null, graph);
}
```

`getQuads` returns an array of quads matching a pattern. Setting any field to
`undefined` or `null` indicates a wildcard.

```javascript
getQuads(subject, predicate, object, graph) {
  return [...this.readQuads(subject, predicate, object, graph)];
}
```

`readQuads` returns an generator of quads matching a pattern. Setting any field
to `undefined` or `null` indicates a wildcard.

```javascript
*readQuads(subject, predicate, object, graph) {
```

Convert terms to internal string representation.

```javascript
graph = graph && termToId(graph);

const graphs = this._getGraphs(graph);
let content, subjectId, predicateId, objectId;
```

Translate IRIs to internal index keys.

```javascript
    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||
        predicate && !(predicateId = this._termToNumericId(predicate)) ||
        object    && !(objectId    = this._termToNumericId(object)))
      return;

    for (const graphId in graphs) {
```

Only if the specified graph contains triples, there can be results.

```javascript
if (content = graphs[graphId]) {
```

Choose the optimal index, based on what fields are present.

```javascript
if (subjectId) {
  if (objectId)
```

If subject and object are given, the object index will be the fastest.

```javascript
  yield* this._findInIndex(content.objects, objectId, subjectId, predicateId,
                    'object', 'subject', 'predicate', graphId);
else
```

If only subject and possibly predicate are given, the subject index will be the
fastest.

```javascript
    yield* this._findInIndex(content.subjects, subjectId, predicateId, null,
                      'subject', 'predicate', 'object', graphId);
}
else if (predicateId)
```

If only predicate and possibly object are given, the predicate index will be the
fastest.

```javascript
  yield* this._findInIndex(content.predicates, predicateId, objectId, null,
                    'predicate', 'object', 'subject', graphId);
else if (objectId)
```

If only object is given, the object index will be the fastest.

```javascript
  yield* this._findInIndex(content.objects, objectId, null, null,
                    'object', 'subject', 'predicate', graphId);
else
```

If nothing is given, iterate subjects and predicates first.

```javascript
        yield* this._findInIndex(content.subjects, null, null, null,
                          'subject', 'predicate', 'object', graphId);
    }
  }
}
```

`forEach` executes the callback on all quads. Setting any field to `undefined`
or `null` indicates a wildcard.

```javascript
forEach(callback, subject, predicate, object, graph) {
  this.some(quad => {
    callback(quad);
    return false;
  }, subject, predicate, object, graph);
}
```

`every` executes the callback on all quads, and returns `true` if it returns
truthy for all them. Setting any field to `undefined` or `null` indicates a
wildcard.

```javascript
every(callback, subject, predicate, object, graph) {
  let some = false;
  const every = !this.some(quad => {
    some = true;
    return !callback(quad);
  }, subject, predicate, object, graph);
  return some && every;
}
```

`some` executes the callback on all quads, and returns `true` if it returns
truthy for any of them. Setting any field to `undefined` or `null` indicates a
wildcard.

```javascript
some(callback, subject, predicate, object, graph) {
  for (const quad of this.readQuads(subject, predicate, object, graph))
    if (callback(quad))
      return true;
  return false;
}
```

`getSubjects` returns all subjects that match the pattern. Setting any field to
`undefined` or `null` indicates a wildcard.

```javascript
getSubjects(predicate, object, graph) {
  const results = [];
  this.forSubjects(s => { results.push(s); }, predicate, object, graph);
  return results;
}
```

`forSubjects` executes the callback on all subjects that match the pattern.
Setting any field to `undefined` or `null` indicates a wildcard.

```javascript
forSubjects(callback, predicate, object, graph) {
```

Convert terms to internal string representation.

```javascript
graph = graph && termToId(graph);

const graphs = this._getGraphs(graph);
let content, predicateId, objectId;
callback = this._uniqueEntities(callback);
```

Translate IRIs to internal index keys.

```javascript
    if (predicate && !(predicateId = this._termToNumericId(predicate)) ||
        object    && !(objectId    = this._termToNumericId(object)))
      return;

    for (graph in graphs) {
```

Only if the specified graph contains triples, there can be results.

```javascript
if (content = graphs[graph]) {
```

Choose optimal index based on which fields are wildcards.

```javascript
if (predicateId) {
  if (objectId)
```

If predicate and object are given, the POS index is best.

```javascript
  this._loopBy2Keys(content.predicates, predicateId, objectId, callback);
else
```

If only predicate is given, the SPO index is best.

```javascript
    this._loopByKey1(content.subjects, predicateId, callback);
}
else if (objectId)
```

If only object is given, the OSP index is best.

```javascript
  this._loopByKey0(content.objects, objectId, callback);
else
```

If no params given, iterate all the subjects.

```javascript
        this._loop(content.subjects, callback);
    }
  }
}
```

`getPredicates` returns all predicates that match the pattern. Setting any field
to `undefined` or `null` indicates a wildcard.

```javascript
getPredicates(subject, object, graph) {
  const results = [];
  this.forPredicates(p => { results.push(p); }, subject, object, graph);
  return results;
}
```

`forPredicates` executes the callback on all predicates that match the pattern.
Setting any field to `undefined` or `null` indicates a wildcard.

```javascript
forPredicates(callback, subject, object, graph) {
```

Convert terms to internal string representation.

```javascript
graph = graph && termToId(graph);

const graphs = this._getGraphs(graph);
let content, subjectId, objectId;
callback = this._uniqueEntities(callback);
```

Translate IRIs to internal index keys.

```javascript
    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||
        object    && !(objectId    = this._termToNumericId(object)))
      return;

    for (graph in graphs) {
```

Only if the specified graph contains triples, there can be results.

```javascript
if (content = graphs[graph]) {
```

Choose optimal index based on which fields are wildcards.

```javascript
if (subjectId) {
  if (objectId)
```

If subject and object are given, the OSP index is best.

```javascript
  this._loopBy2Keys(content.objects, objectId, subjectId, callback);
else
```

If only subject is given, the SPO index is best.

```javascript
    this._loopByKey0(content.subjects, subjectId, callback);
}
else if (objectId)
```

If only object is given, the POS index is best.

```javascript
  this._loopByKey1(content.predicates, objectId, callback);
else
```

If no params given, iterate all the predicates.

```javascript
        this._loop(content.predicates, callback);
    }
  }
}
```

`getObjects` returns all objects that match the pattern. Setting any field to
`undefined` or `null` indicates a wildcard.

```javascript
getObjects(subject, predicate, graph) {
  const results = [];
  this.forObjects(o => { results.push(o); }, subject, predicate, graph);
  return results;
}
```

`forObjects` executes the callback on all objects that match the pattern.
Setting any field to `undefined` or `null` indicates a wildcard.

```javascript
forObjects(callback, subject, predicate, graph) {
```

Convert terms to internal string representation.

```javascript
graph = graph && termToId(graph);

const graphs = this._getGraphs(graph);
let content, subjectId, predicateId;
callback = this._uniqueEntities(callback);
```

Translate IRIs to internal index keys.

```javascript
    if (subject   && !(subjectId   = this._termToNumericId(subject))   ||
        predicate && !(predicateId = this._termToNumericId(predicate)))
      return;

    for (graph in graphs) {
```

Only if the specified graph contains triples, there can be results.

```javascript
if (content = graphs[graph]) {
```

Choose optimal index based on which fields are wildcards.

```javascript
if (subjectId) {
  if (predicateId)
```

If subject and predicate are given, the SPO index is best.

```javascript
  this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);
else
```

If only subject is given, the OSP index is best.

```javascript
    this._loopByKey1(content.objects, subjectId, callback);
}
else if (predicateId)
```

If only predicate is given, the POS index is best.

```javascript
  this._loopByKey0(content.predicates, predicateId, callback);
else
```

If no params given, iterate all the objects.

```javascript
        this._loop(content.objects, callback);
    }
  }
}
```

`getGraphs` returns all graphs that match the pattern. Setting any field to
`undefined` or `null` indicates a wildcard.

```javascript
getGraphs(subject, predicate, object) {
  const results = [];
  this.forGraphs(g => { results.push(g); }, subject, predicate, object);
  return results;
}
```

`forGraphs` executes the callback on all graphs that match the pattern. Setting
any field to `undefined` or `null` indicates a wildcard.

```javascript
forGraphs(callback, subject, predicate, object) {
  for (const graph in this._graphs) {
    this.some(quad => {
      callback(quad.graph);
      return true; // Halt iteration of some()
    }, subject, predicate, object, graph);
  }
}
```

`createBlankNode` creates a new blank node, returning its name.

```javascript
createBlankNode(suggestedName) {
  let name, index;
```

Generate a name based on the suggested name.

```javascript
if (suggestedName) {
  name = suggestedName = `_:${suggestedName}`, index = 1;
  while (this._ids[name]) {
    name = suggestedName + index++;
  }
}
```

Generate a generic blank node name.

```javascript
else {
  do { name = `_:b${this._blankNodeIndex++}`; }
  while (this._ids[name]);
}
```

Add the blank node to the entities, avoiding the generation of duplicates.

```javascript
  this._ids[name] = ++this._id;
  this._entities[this._id] = name;
  return this._factory.blankNode(name.substr(2));
}
```

`extractLists` finds and removes all list triples and returns the items per
list.

```javascript
extractLists({ remove = false, ignoreErrors = false } = {}) {
  const lists = {}; // has scalar keys so could be a simple Object
  const onError = ignoreErrors ? (() => true) :
                ((node, message) => { throw new Error(`${node.value} ${message}`); });
```

Traverse each list from its tail.

```javascript
const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);
const toRemove = remove ? [...tails] : [];
tails.forEach(tailQuad => {
  const items = [];             // the members found as objects of rdf:first quads
  let malformed = false;      // signals whether the current list is malformed
  let head;                   // the head of the list (_:b1 in above example)
  let headPos;                // set to subject or object when head is set
  const graph = tailQuad.graph; // make sure list is in exactly one graph
```

Traverse the list from tail to end.

```javascript
let current = tailQuad.subject;
while (current && !malformed) {
  const objectQuads = this.getQuads(null, null, current, null);
  const subjectQuads = this.getQuads(current, null, null, null);
  let quad, first = null, rest = null, parent = null;
```

Find the first and rest of this list node.

```javascript
for (let i = 0; i < subjectQuads.length && !malformed; i++) {
  quad = subjectQuads[i];
  if (!quad.graph.equals(graph))
    malformed = onError(current, 'not confined to single graph');
  else if (head)
    malformed = onError(current, 'has non-list arcs out');
```

One `rdf:first`.

```javascript
else if (quad.predicate.value === namespaces.rdf.first) {
  if (first)
    malformed = onError(current, 'has multiple rdf:first arcs');
  else
    toRemove.push(first = quad);
}
```

One `rdf:rest`.

```javascript
else if (quad.predicate.value === namespaces.rdf.rest) {
  if (rest)
    malformed = onError(current, 'has multiple rdf:rest arcs');
  else
    toRemove.push(rest = quad);
}
```

Alien triple.

```javascript
  else if (objectQuads.length)
    malformed = onError(current, 'can\'t be subject and object');
  else {
    head = quad; // e.g. { (1 2 3) :p :o }
    headPos = 'subject';
  }
}
```

`{ :s :p (1 2) }` arrives here with no head. `{ (1 2) :p :o }` arrives here with
head set to the list.

```javascript
for (let i = 0; i < objectQuads.length && !malformed; ++i) {
  quad = objectQuads[i];
  if (head)
    malformed = onError(current, 'can\'t have coreferences');
```

One `rdf:rest`.

```javascript
  else if (quad.predicate.value === namespaces.rdf.rest) {
    if (parent)
      malformed = onError(current, 'has incoming rdf:rest arcs');
    else
      parent = quad;
  }
  else {
    head = quad; // e.g. { :s :p (1 2) }
    headPos = 'object';
  }
}
```

Store the list item and continue with parent.

```javascript
  if (!first)
    malformed = onError(current, 'has no list head');
  else
    items.unshift(first.object);
  current = parent && parent.subject;
}
```

Don’t remove any quads if the list is malformed.

```javascript
if (malformed) {
  remove = false;
}
```

Store the list under the value of its head.

```javascript
  else if (head)
    lists[head[headPos].value] = items;
});
```

Remove list quads if requested.

```javascript
  if (remove)
    this.removeQuads(toRemove);
  return lists;
}
```

Store is an iterable. Can be used where iterables are expected: `for...of`
loops, array spread operator, `yield*`, and destructuring assignment (order is
not guaranteed).

```javascript
  *[Symbol.iterator]() {
    yield* this.readQuads();
  } 
}
```

Determines whether the argument is a string.

```javascript
function isString(s) {
  return typeof s === "string" || s instanceof String;
}
```

A class that implements both DatasetCore and Readable.

```javascript
class DatasetCoreAndReadableStream extends Readable {
  constructor(n3Store, subject, predicate, object, graph) {
    super({ objectMode: true });
    Object.assign(this, { n3Store, subject, predicate, object, graph });
  }

  get filtered() {
    if (!this._filtered) {
      const { n3Store, graph, object, predicate, subject } = this;
      const newStore = this._filtered = new N3Store({
        factory: n3Store._factory,
      });
      for (const quad of n3Store.readQuads(subject, predicate, object, graph)) {
        newStore.addQuad(quad);
      }
    }
    return this._filtered;
  }

  get size() {
    return this.filtered.size;
  }

  _read() {
    for (const quad of this) {
      this.push(quad);
    }
    this.push(null);
  }

  add(quad) {
    return this.filtered.add(quad);
  }

  delete(quad) {
    return this.filtered.delete(quad);
  }

  has(quad) {
    return this.filtered.has(quad);
  }

  match(subject, predicate, object, graph) {
    return new DatasetCoreAndReadableStream(
      this.filtered,
      subject,
      predicate,
      object,
      graph,
    );
  }

  *[Symbol.iterator]() {
    yield* this._filtered ||
      this.n3Store.readQuads(
        this.subject,
        this.predicate,
        this.object,
        this.graph,
      );
  }
}
```

---

## N3StreamParser.js

**N3StreamParser** parses a text stream into a quad stream.

```javascript
import { Transform } from "readable-stream";
import N3Parser from "./N3Parser";
```

### Constructor

```javascript
export default class N3StreamParser extends Transform {
  constructor(options) {
    super({ decodeStrings: true });
    this._readableState.objectMode = true;
```

Set up parser with dummy stream to obtain `data` and `end` callbacks.

```javascript
const parser = new N3Parser(options);
let onData, onEnd;
parser.parse({
  on: (event, callback) => {
    switch (event) {
    case 'data': onData = callback; break;
    case 'end':   onEnd = callback; break;
    }
  },
},
```

Handle quads by pushing them down the pipeline.

```javascript
(error, quad) => { error && this.emit('error', error) || quad && this.push(quad); },
```

Emit prefixes through the `prefix` event.

```javascript
  (prefix, uri) => { this.emit('prefix', prefix, uri); }
);
```

Implement Transform methods through parser callbacks.

```javascript
  this._transform = (chunk, encoding, done) => { onData(chunk); done(); };
  this._flush = done => { onEnd(); done(); };
}
```

Parses a stream of strings.

```javascript
  import(stream) {
    stream.on('data',  chunk => { this.write(chunk); });
    stream.on('end',   ()      => { this.end(); });
    stream.on('error', error => { this.emit('error', error); });
    return this;
  } 
}
```

---

## N3StreamWriter.js

**N3StreamWriter** serializes a quad stream into a text stream.

```javascript
import { Transform } from "readable-stream";
import N3Writer from "./N3Writer";
```

### Constructor

```javascript
export default class N3StreamWriter extends Transform {
  constructor(options) {
    super({ encoding: 'utf8', writableObjectMode: true });
```

Set up writer with a dummy stream object.

```javascript
const writer = this._writer = new N3Writer({
  write: (quad, encoding, callback) => {
    this.push(quad);
    callback && callback();
  },
  end: (callback) => {
    this.push(null);
    callback && callback();
  },
}, options);
```

Implement Transform methods on top of writer.

```javascript
  this._transform = (quad, encoding, done) => { writer.addQuad(quad, done); };
  this._flush = done => { writer.end(done); };
}
```

Serializes a stream of quads.

```javascript
  import(stream) {
    stream.on('data',   quad => { this.write(quad); });
    stream.on('end',    () => { this.end(); });
    stream.on('error',  error => { this.emit('error', error); });
    stream.on('prefix', (prefix, iri) => { this._writer.addPrefix(prefix, iri); });
    return this;
  } 
}
```

---

## N3Util.js

**N3Util** provides N3 utility functions.

```javascript
import N3DataFactory from "./N3DataFactory";
```

Tests whether the given term represents an IRI.

```javascript
export function isNamedNode(term) {
  return !!term && term.termType === "NamedNode";
}
```

Tests whether the given term represents a blank node.

```javascript
export function isBlankNode(term) {
  return !!term && term.termType === "BlankNode";
}
```

Tests whether the given term represents a literal.

```javascript
export function isLiteral(term) {
  return !!term && term.termType === "Literal";
}
```

Tests whether the given term represents a variable.

```javascript
export function isVariable(term) {
  return !!term && term.termType === "Variable";
}
```

Tests whether the given term represents the default graph.

```javascript
export function isDefaultGraph(term) {
  return !!term && term.termType === "DefaultGraph";
}
```

Tests whether the given quad is in the default graph.

```javascript
export function inDefaultGraph(quad) {
  return isDefaultGraph(quad.graph);
}
```

Creates a function that prepends the given IRI to a local name.

```javascript
export function prefix(iri, factory) {
  return prefixes({ "": iri.value || iri }, factory)("");
}
```

Creates a function that allows registering and expanding prefixes.

```javascript
export function prefixes(defaultPrefixes, factory) {
```

Add all of the default prefixes.

```javascript
const prefixes = Object.create(null);
for (const prefix in defaultPrefixes) {
  processPrefix(prefix, defaultPrefixes[prefix]);
}
```

Set the default factory if none was specified.

```javascript
factory = factory || N3DataFactory;
```

Registers a new prefix (if an IRI was specified) or retrieves a function that
expands an existing prefix (if no IRI was specified).

```javascript
function processPrefix(prefix, iri) {
```

Create a new prefix if an IRI is specified or the prefix doesn’t exist.

```javascript
if (typeof iri === 'string') {
```

Create a function that expands the prefix.

```javascript
      const cache = Object.create(null);
      prefixes[prefix] = local => {
        return cache[local] || (cache[local] = factory.namedNode(iri + local));
      };
    }
    else if (!(prefix in prefixes)) {
      throw new Error(`Unknown prefix: ${prefix}`);
    }
    return prefixes[prefix];
  }
  return processPrefix; 
}
```

---

## N3Writer.js

**N3Writer** writes N3 documents.

```javascript
import namespaces from "./IRIs";
import { default as N3DataFactory, Term } from "./N3DataFactory";
import { isDefaultGraph } from "./N3Util";

const DEFAULTGRAPH = N3DataFactory.defaultGraph();
const { rdf, xsd } = namespaces;
```

Characters in literals that require escaping.

```javascript
const escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/,
  escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g,
  escapedCharacters = {
    "\\": "\\\\",
    '"': '\\"',
    "\t": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\b": "\\b",
    "\f": "\\f",
  };
```

### Placeholder class to represent already pretty-printed terms

```javascript
class SerializedTerm extends Term {
```

Pretty-printed nodes are not equal to any other node (e.g., `[]` does not equal
`[]`).

```javascript
  equals(other) {
    return other === this;
  } 
}
```

### Constructor

```javascript
export default class N3Writer {
  constructor(outputStream, options) {
```

`_prefixRegex` matches a prefixed name or IRI that begins with one of the added
prefixes.

```javascript
this._prefixRegex = /$0^/;
```

Shift arguments if the first argument is not a stream.

```javascript
if (outputStream && typeof outputStream.write !== "function") {
  options = outputStream, outputStream = null;
}
options = options || {};
this._lists = options.lists;
```

If no output stream given, send the output as string through the end callback.

```javascript
if (!outputStream) {
  let output = "";
  this._outputStream = {
    write(chunk, encoding, done) {
      output += chunk;
      done && done();
    },
    end: (done) => {
      done && done(null, output);
    },
  };
  this._endStream = true;
} else {
  this._outputStream = outputStream;
  this._endStream = options.end === undefined ? true : !!options.end;
}
```

Initialize writer, depending on the format.

```javascript
  this._subject = null;
  if (!(/triple|quad/i).test(options.format)) {
    this._lineMode = false;
    this._graph = DEFAULTGRAPH;
    this._prefixIRIs = Object.create(null);
    options.prefixes && this.addPrefixes(options.prefixes);
    if (options.baseIRI) {
      this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)
          }${options.baseIRI.endsWith('/') ? '' : '[#?]'}`);
      this._baseLength = options.baseIRI.length;
    }
  }
  else {
    this._lineMode = true;
    this._writeQuad = this._writeQuadLine;
  }
}
```

### Private methods

Whether the current graph is the default graph.

```javascript
get _inDefaultGraph() {
  return DEFAULTGRAPH.equals(this._graph);
}
```

`_write` writes the argument to the output stream.

```javascript
_write(string, callback) {
  this._outputStream.write(string, 'utf8', callback);
}
```

`_writeQuad` writes the quad to the output stream.

```javascript
_writeQuad(subject, predicate, object, graph, done) {
  try {
```

Write the graph’s label if it has changed.

```javascript
if (!graph.equals(this._graph)) {
```

Close the previous graph and start the new one.

```javascript
  this._write((this._subject === null ? '' : (this._inDefaultGraph ? '.\n' : '\n}\n')) +
              (DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\n`));
  this._graph = graph;
  this._subject = null;
}
```

Don’t repeat the subject if it’s the same.

```javascript
if (subject.equals(this._subject)) {
```

Don’t repeat the predicate if it’s the same.

```javascript
if (predicate.equals(this._predicate)) {
  this._write(`, ${this._encodeObject(object)}`, done);
}
```

Same subject, different predicate.

```javascript
  else
    this._write(`;\n    ${
                this._encodePredicate(this._predicate = predicate)} ${
                this._encodeObject(object)}`, done);
}
```

Different subject; write the whole quad.

```javascript
    else
      this._write(`${(this._subject === null ? '' : '.\n') +
                  this._encodeSubject(this._subject = subject)} ${
                  this._encodePredicate(this._predicate = predicate)} ${
                  this._encodeObject(object)}`, done);
  }
  catch (error) { done && done(error); }
}
```

`_writeQuadLine` writes the quad to the output stream as a single line.

```javascript
_writeQuadLine(subject, predicate, object, graph, done) {
```

Write the quad without prefixes.

```javascript
  delete this._prefixMatch;
  this._write(this.quadToString(subject, predicate, object, graph), done);
}
```

`quadToString` serializes a quad as a string.

```javascript
quadToString(subject, predicate, object, graph) {
  return  `${this._encodeSubject(subject)} ${
          this._encodeIriOrBlank(predicate)} ${
          this._encodeObject(object)
          }${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\n` : ' .\n'}`;
}
```

`quadsToString` serializes an array of quads as a string.

```javascript
quadsToString(quads) {
  return quads.map(t => {
    return this.quadToString(t.subject, t.predicate, t.object, t.graph);
  }).join('');
}
```

`_encodeSubject` represents a subject.

```javascript
_encodeSubject(entity) {
  return entity.termType === 'Quad' ?
    this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
}
```

`_encodeIriOrBlank` represents an IRI or blank node.

```javascript
_encodeIriOrBlank(entity) {
```

A blank node or list is represented as-is.

```javascript
if (entity.termType !== 'NamedNode') {
```

If it is a list head, pretty-print it.

```javascript
  if (this._lists && (entity.value in this._lists))
    entity = this.list(this._lists[entity.value]);
  return 'id' in entity ? entity.id : `_:${entity.value}`;
}
let iri = entity.value;
```

Use relative IRIs if requested and possible.

```javascript
if (this._baseMatcher && this._baseMatcher.test(iri)) {
  iri = iri.substr(this._baseLength);
}
```

Escape special characters.

```javascript
if (escape.test(iri)) {
  iri = iri.replace(escapeAll, characterReplacer);
}
```

Try to represent the IRI as prefixed name.

```javascript
  const prefixMatch = this._prefixRegex.exec(iri);
  return !prefixMatch ? `<${iri}>` :
         (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);
}
```

`_encodeLiteral` represents a literal.

```javascript
_encodeLiteral(literal) {
```

Escape special characters.

```javascript
let value = literal.value;
if (escape.test(value)) {
  value = value.replace(escapeAll, characterReplacer);
}
```

Write a language-tagged literal.

```javascript
if (literal.language) {
  return `"${value}"@${literal.language}`;
}
```

Write dedicated literals per data type.

```javascript
if (this._lineMode) {
```

Only abbreviate strings in N-Triples or N-Quads.

```javascript
  if (literal.datatype.value === xsd.string)
    return `"${value}"`;
}
else {
```

Use common datatype abbreviations in Turtle or TriG.

```javascript
  switch (literal.datatype.value) {
  case xsd.string:
    return `"${value}"`;
  case xsd.boolean:
    if (value === 'true' || value === 'false')
      return value;
    break;
  case xsd.integer:
    if (/^[+-]?\d+$/.test(value))
      return value;
    break;
  case xsd.decimal:
    if (/^[+-]?\d*\.\d+$/.test(value))
      return value;
    break;
  case xsd.double:
    if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(value))
      return value;
    break;
  }
}
```

Write a regular datatyped literal.

```javascript
  return `"${value}"^^${this._encodeIriOrBlank(literal.datatype)}`;
}
```

`_encodePredicate` represents a predicate.

```javascript
_encodePredicate(predicate) {
  return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);
}
```

`_encodeObject` represents an object.

```javascript
_encodeObject(object) {
  switch (object.termType) {
  case 'Quad':
    return this._encodeQuad(object);
  case 'Literal':
    return this._encodeLiteral(object);
  default:
    return this._encodeIriOrBlank(object);
  }
}
```

`_encodeQuad` encodes an RDF\* quad.

```javascript
_encodeQuad({ subject, predicate, object, graph }) {
  return `<<${
    this._encodeSubject(subject)} ${
    this._encodePredicate(predicate)} ${
    this._encodeObject(object)}${
    isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;
}
```

`_blockedWrite` replaces `_write` after the writer has been closed.

```javascript
_blockedWrite() {
  throw new Error('Cannot write because the writer has been closed.');
}
```

`addQuad` adds the quad to the output stream.

```javascript
addQuad(subject, predicate, object, graph, done) {
```

The quad was given as an object, so shift parameters.

```javascript
if (object === undefined) {
  this._writeQuad(
    subject.subject,
    subject.predicate,
    subject.object,
    subject.graph,
    predicate,
  );
}
```

The optional `graph` parameter was not provided.

```javascript
else if (typeof graph === 'function')
  this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);
```

The `graph` parameter was provided.

```javascript
  else
    this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);
}
```

`addQuads` adds the quads to the output stream.

```javascript
addQuads(quads) {
  for (let i = 0; i < quads.length; i++)
    this.addQuad(quads[i]);
}
```

`addPrefix` adds the prefix to the output stream.

```javascript
addPrefix(prefix, iri, done) {
  const prefixes = {};
  prefixes[prefix] = iri;
  this.addPrefixes(prefixes, done);
}
```

`addPrefixes` adds the prefixes to the output stream.

```javascript
addPrefixes(prefixes, done) {
```

Ignore prefixes if not supported by the serialization.

```javascript
if (!this._prefixIRIs) {
  return done && done();
}
```

Write all new prefixes.

```javascript
let hasPrefixes = false;
for (let prefix in prefixes) {
  let iri = prefixes[prefix];
  if (typeof iri !== 'string')
    iri = iri.value;
  hasPrefixes = true;
```

Finish a possible pending quad.

```javascript
if (this._subject !== null) {
  this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
  this._subject = null, this._graph = "";
}
```

Store and write the prefix.

```javascript
  this._prefixIRIs[iri] = (prefix += ':');
  this._write(`@prefix ${prefix} <${iri}>.\n`);
}
```

Recreate the prefix matcher.

```javascript
if (hasPrefixes) {
  let IRIlist = "", prefixList = "";
  for (const prefixIRI in this._prefixIRIs) {
    IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;
    prefixList += (prefixList ? "|" : "") + this._prefixIRIs[prefixIRI];
  }
  IRIlist = escapeRegex(IRIlist, /[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
  this._prefixRegex = new RegExp(
    `^(?:${prefixList})[^\/]*$|` +
      `^(${IRIlist})([_a-zA-Z][\\-_a-zA-Z0-9]*)$`,
  );
}
```

End a prefix block with a newline.

```javascript
  this._write(hasPrefixes ? '\n' : '', done);
}
```

`blank` creates a blank node with the given content.

```javascript
blank(predicate, object) {
  let children = predicate, child, length;
```

Empty blank node.

```javascript
if (predicate === undefined) {
  children = [];
}
```

Blank node passed as `blank(Term(“predicate”), Term(“object”))`.

```javascript
else if (predicate.termType)
  children = [{ predicate: predicate, object: object }];
```

Blank node passed as `blank({ predicate: predicate, object: object })`.

```javascript
    else if (!('length' in predicate))
      children = [predicate];

    switch (length = children.length) {
```

Generate an empty blank node.

```javascript
case 0:
  return new SerializedTerm('[]');
```

Generate a non-nested one-triple blank node.

```javascript
case 1:
  child = children[0];
  if (!(child.object instanceof SerializedTerm))
    return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${
                              this._encodeObject(child.object)} ]`);
```

Generate a multi-triple or nested blank node.

```javascript
default:
  let contents = '[';
```

Write all triples in order.

```javascript
for (let i = 0; i < length; i++) {
  child = children[i];
```

Write only the object is the predicate is the same as the previous.

```javascript
if (child.predicate.equals(predicate)) {
  contents += `, ${this._encodeObject(child.object)}`;
}
```

Otherwise, write the predicate and the object.

```javascript
      else {
        contents += `${(i ? ';\n  ' : '\n  ') +
                    this._encodePredicate(child.predicate)} ${
                    this._encodeObject(child.object)}`;
        predicate = child.predicate;
      }
    }
    return new SerializedTerm(`${contents}\n]`);
  }
}
```

`list` creates a list node with the given content.

```javascript
list(elements) {
  const length = elements && elements.length || 0, contents = new Array(length);
  for (let i = 0; i < length; i++)
    contents[i] = this._encodeObject(elements[i]);
  return new SerializedTerm(`(${contents.join(' ')})`);
}
```

`end` signals the end of the output stream.

```javascript
end(done) {
```

Finish a possible pending quad.

```javascript
if (this._subject !== null) {
  this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
  this._subject = null;
}
```

Disallow further writing.

```javascript
this._write = this._blockedWrite;
```

Try to end the underlying stream, ensuring done is called exactly one time.

```javascript
    let singleDone = done && ((error, result) => { singleDone = null, done(error, result); });
    if (this._endStream) {
      try { return this._outputStream.end(singleDone); }
      catch (error) { /* error closing stream */ }
    }
    singleDone && singleDone();
  } 
}
```

Replaces a character by its escaped version.

```javascript
function characterReplacer(character) {
```

Replace a single character by its escaped version.

```javascript
  let result = escapedCharacters[character];

  if (result === undefined) {
```

Replace a single character with its 4-bit unicode escape sequence.

```javascript
if (character.length === 1) {
  result = character.charCodeAt(0).toString(16);
  result = "\\u0000".substr(0, 6 - result.length) + result;
}
```

Replace a surrogate pair with its 8-bit unicode escape sequence.

```javascript
    else {
      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +
                 character.charCodeAt(1) + 0x2400).toString(16);
      result = '\\U00000000'.substr(0, 10 - result.length) + result;
    }
  }
  return result; 
}

function escapeRegex(regex) {
  return regex.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, '\\$&'); 
}
```
